<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yingu的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yingu.site/"/>
  <updated>2021-07-18T12:59:50.090Z</updated>
  <id>https://yingu.site/</id>
  
  <author>
    <name>yingu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DDD学习</title>
    <link href="https://yingu.site/2021/07/18/DDD-learn/"/>
    <id>https://yingu.site/2021/07/18/DDD-learn/</id>
    <published>2021-07-18T12:44:54.000Z</published>
    <updated>2021-07-18T12:59:50.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着业务的不断扩展，代码量的不断攀升，慢慢的我们的代码越来越臃肿且难以维护，程序开始变得不可控。当初设计的架构，在如今快速迭代的场景下，变得越来越松散，而重构也变得越来越困难。传统的三层架构，已无法满足当今业务快速迭代下的考验，而我们开始探索一种新的架构思想：DDD。<a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;随着业务的不断扩展，代码量的不断攀升，慢慢的我们的代码越来越臃肿且难以维护，程序开始变得不可控。当初设计的架构，在如今快速迭代的场景下，变得越来越松散，而重构也变得越来越困难。传统的三层架构，已无法满足当今业务快速迭代下的考验，而我们开始探索一种新的架构思想：DDD。
    
    </summary>
    
    
      <category term="架构" scheme="https://yingu.site/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="DDD" scheme="https://yingu.site/tags/DDD/"/>
    
      <category term="架构" scheme="https://yingu.site/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MySqlSummary</title>
    <link href="https://yingu.site/2021/07/18/MySqlSummary/"/>
    <id>https://yingu.site/2021/07/18/MySqlSummary/</id>
    <published>2021-07-18T12:31:14.986Z</published>
    <updated>2021-07-18T12:34:26.327Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><p>title: mysql总结</p><p>author: yingu</p><p>thumbnail: <a href="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/cs/cs-20.jpg">http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/cs/cs-20.jpg</a></p><p>toc: true </p><p>tags:</p><ul><li>mysql</li><li>工具</li><li>数据库</li></ul><p>categories: </p><ul><li>[工具,mysql] </li></ul><p>date: 2020-05-04 13:15:42</p><hr><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MySql支持多种存储引擎，通过navicat新建表可以看到，MySql一共支持7种存储引擎。我们平时听到最多的MyISAM与InnoDB就在其中。MyISAM是5.1版本之前的默认引擎，5.1之后InnoDB就成为了Mysql的默认引擎，一直沿用至今。那么这两种引擎之间有什么区别呢？<a id="more"></a><br><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/mysql_engine.png" alt=""></p><table><thead><tr><th></th><th>全文检索</th><th>事务</th><th>锁</th><th>外键</th><th>数据类型</th><th>MVCC</th></tr></thead><tbody><tr><td>InnoDB</td><td>不支持(5.6及以上支持)</td><td>支持</td><td>支持行锁</td><td>支持</td><td>聚簇索引</td><td>支持</td></tr><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td>只支持表锁</td><td>不支持</td><td>非聚簇索引</td><td>不支持</td></tr></tbody></table><p><strong>InnoDB与MyISAM区别：</strong></p><p>由于MyISAM不支持事务和行锁，因此针对数据的写操作，会锁住整张表，这在高并发情况下是极为不利的。因此MyISAM只适合大量查询少量插入的场景来使用。而InnoDB支持行锁，外键，并且可以通过MVCC来支持高并发，因此在高并发下情况下，InnoDB有更好的表现。</p><p>InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。</p><p>对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务。</p><p><strong>InnoDB为什么推荐使用自增ID作为主键？</strong></p><p>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><p><strong>InnoDb与Myisam数据存储在哪里？以什么方式？</strong></p><p>Innodb存储文件有FRM(表框架)、IDB(索引与表数据)</p><p>Myisam存储文件有FRM(表框架)、MYD(表数据)、MYI(索引数据）</p><p><strong>InnoDb四大特性</strong></p><ul><li>插入缓冲（insert buffer)：在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(<a href="#changebuffer">change buffer</a>)。</li><li>二次写(double write)：<a href="#doublewrite">doublewrite buffer</a></li><li>自适应哈希索引(ahi)：由于通过二级索引查找数据行时，每次都要去查找对应的主键值后，才能去主键索引中找到数据行。而这种方式会导致进行了两次B+TREE的查找工作。因此Innodb存储引擎会监控对表上二级索引的查找，如果观察到建立哈希索引可以带来速度提升，则建立<strong>哈希索引</strong>,称之为<strong>自适应哈希索引</strong>。自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。(hash表类似于HashMap的桶)</li><li>预读(read ahead)：磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="逻辑角度"><a href="#逻辑角度" class="headerlink" title="逻辑角度"></a>逻辑角度</h4><ul><li><p>普通索引：最基本的索引，没有任何限制。</p></li><li><p>唯一索引：要求关键字不能重复。同时增加唯一约束。</p></li><li><p>主键索引：要求关键字不能重复，也不能为NULL，同时增加主键约束，且可以被其他表应用为外键。</p></li><li><p>组合索引：将几个列作为一条索引进行检索，使用最左匹配原则。</p></li><li><p>全文索引：关键字的来源不是所有字段的数据，而是从字段中提取的特别关键词。</p></li></ul><h4 id="存储角度"><a href="#存储角度" class="headerlink" title="存储角度"></a>存储角度</h4><h5 id="聚簇索引-聚集索引"><a href="#聚簇索引-聚集索引" class="headerlink" title="聚簇索引(聚集索引)"></a>聚簇索引(聚集索引)</h5><p><strong>特点</strong></p><ul><li>聚簇索引就是按照每张表的主键构造一颗B+树，用来保存索引与数据。</li><li>索引结构的叶子节点存储整张表的行数据。数据的物理存放顺序与索引顺序是一致的。</li><li>由于聚簇索引是通过主键来将数据聚集，因此使用聚簇索引的引擎不能没有主键。如果表中没有定义主键，那么 InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，那么InnoDB 会隐式定义一个主键，来作为聚簇索引。</li><li>聚簇索引的每个叶子节点都包含了键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。</li><li>聚集索引是 InnoDB引擎下主键索引的实现， InnoDB引擎中每张表只能有一个<strong>聚簇索引</strong>。</li></ul><p><strong>检索过程</strong></p><ul><li>由于聚簇索引中主键索引与数据放到了一起，所以通过主键索引来检索的之后，可以直接查找对应主键的行数据。</li><li>通过辅助索引查数据时，首先查到索引位置对应的主键值，然后通过主键值去主键索引中，查找对应的行数据。</li></ul><p><strong>优点</strong></p><ul><li><p>可以把相关数据保存在一起。</p></li><li><p>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。</p></li><li><p>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p></li></ul><p><strong>缺点</strong></p><ul><li>插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong>。但如果不是按照主键顺序加载数据，那么加载完成后最好使用<code>OPTIMIZE TABLE</code> (碎片整理)命令来重新组织一下表。</li><li>更新聚簇索引的代价很高，因为会强制InooDB将每个更新的数据移动到新的位置。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li>二级索引(辅助索引)访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><h5 id="非聚簇索引-辅助索引"><a href="#非聚簇索引-辅助索引" class="headerlink" title="非聚簇索引(辅助索引)"></a>非聚簇索引(辅助索引)</h5><ul><li>非聚簇索引是将索引与数据分开存储，索引结构的叶子节点指向了数据对应的物理地址。</li><li>由于表数据存放在独立的位置，因此辅助索引访问数据总是需要二次查找。</li><li>辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</li><li>非聚集索引是 MyISAM引擎下的索引实现。</li></ul><p><strong>检索过程</strong></p><ul><li>由于非聚簇索引表数据单独存放，因此无论是通过主键索引还是二级索引的方式，都需要通过查找到的表行记录指针去查找对应的表数据。</li></ul><p><strong>优点</strong>：</p><ul><li>插入速度不依赖插入顺序，插入速率快。</li></ul><p><strong>缺点</strong>：</p><ul><li>检索效率低于聚簇索引，每次定位数据需要二次查找。</li></ul><h3 id="使用角度"><a href="#使用角度" class="headerlink" title="使用角度"></a>使用角度</h3><ul><li>覆盖索引：索引是高效找到行的一个方法，当能通过二级索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</li><li>索引下推：索引下推具体是在复合索引的查询中，针对特定的过滤条件而进行减少回表次数而做的优化。</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>MySql中储存索引的方法有两种：B+TREE、HASH，MySql默认采用的B+TREE，那么为什么MySql不用其他数据结构来存储呢？</p><ul><li><p><strong>二叉树</strong>：二分查找法，会有左倾或者右倾的情况，且不适合做范围查询。</p></li><li><p><strong>平衡二叉树</strong>：避免的左倾和右倾，但是数据量大的时候，树高会很高，也就是IO次数会很多，并且存储的数据少。</p></li><li><p><strong>B-Tree</strong>：相比平衡二叉树，树高是降低了，但是还是不适合范围查询，范围查询需要遍历所有数据。</p></li><li><p><strong>B+Tree</strong>：将所有数据都放到叶子节点，所有的叶子结点使用链表相连(可以做范围查询），非叶子节点只放键值，每个数据叶中的有效数据就多了，可以减少IO次数。</p></li></ul><h4 id="B-TREE"><a href="#B-TREE" class="headerlink" title="B-TREE"></a><strong>B-TREE</strong></h4><ul><li><p>绝对平衡树，所有的叶子节点都为同一高度。</p></li><li><p>每个节点都是一个二元数组: [key, data]，所有节点都可以存储数据。key为索引key,data为除key之外的数据。</p></li><li><p>区间查找可能需要返回上层节点重复遍历，IO操作繁琐。</p></li></ul><h4 id="B-TREE-1"><a href="#B-TREE-1" class="headerlink" title="B+TREE"></a><strong>B+TREE</strong></h4><ul><li><p>B-TREE的变种，B -TREE能解决的问题，B+TREE也能够解决（降低树的高度，增大节点存储数据量）。</p></li><li><p>非叶子节点不存储data，只存储索引，可以存放更多的索引。</p></li><li><p>Mysql中B+Tree，在经典B+Tree的基础上进行了优化，增加了双向指针。（经典的B+TREE只有单项指针）</p></li><li><p>查询所有数据时，只需要扫描所有的叶子节点，并且所有的叶子节点相连。</p></li><li><p>B+TREE磁盘读写能力更强。他的根节点和支节点不保存数据区，所以根节点和支节点同样大小的情况下，保存的关键字要比B TREE要多。而叶子节点不保存子节点引用，能用于保存更多的关键字和数据。所以，B+TREE读写一次磁盘加载的关键字比B -TREE更多。</p></li><li><p>B+TREE查询性能稳定。B+TREE数据只保存在叶子节点，每次查询数据，查询IO次数一定是稳定的。当然这个每个人的理解都不同，因为在B TREE如果根节点命中直接返回，确实效率更高。</p></li></ul><h4 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h4><ul><li>对索引的key进行一次hash计算，计算就可以定位出数据存储的位置。</li><li>很多时候HASH索引比B+TREE索引更高效。</li><li>仅能满足“=”，“in”，不支持范围查找。</li><li>会产生hash冲突问题。</li></ul><h3 id="InnoDb引擎"><a href="#InnoDb引擎" class="headerlink" title="InnoDb引擎"></a>InnoDb引擎</h3><p>下图为innodb官方提供的架构图：</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/innodb.png" alt="INNODB官方架构图"></p><p>​    下图为buffer pool结构图：</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/buffer%20pool.png" alt="buffer poll"></p><p>在MySql中我们插入的数据库存储引擎存储，最终持久化到磁盘。当我们查询存储的数据时，又通过存储引擎将数据加载到内存。为了加速数据的访问，MySql会将热点数据放入缓存中，避免每次去查询数据库。而我们的InnoDb作为MySql的一个存储引擎，内部的buffer pool就是为此而设计的。</p><p><strong>buffer pool是如何被使用的呢？</strong></p><p>当我们通过mysql查询一条数据时，mysql从磁盘中读取到数据所属的页，mysql会先将查询的页缓存到buffer pool中，下次查询相同数据时，直接通过buffer pool中缓存的页数据。</p><p><strong>mysql查询数据时，如果知道放入buffer pool的那个位置呢？</strong></p><p><strong>free链表</strong>用来记录我们buffer pool中空闲区的位置，当我们需要向buffer pool中缓存数据时，会查询free链表头部节点的下一个节点的buffer pool空闲的位置，将数据插入到该位置，并在free链表中将此节点删除。</p><p><strong>mysql修改数据时，innodb是如何操作的？</strong></p><p>mysql修改数据时，buffer pool中如果存放着该数据对应的页，那么此时为了同步数据，Innodb不仅需要更新buffer pool中缓存的页，还需要修改磁盘中的页。但Innodb为了避免频繁的访问磁盘，仅仅修改了buffer pool中的页数据，又通过后台线程定时将修改的数据刷新到磁盘，此时未被持久化到磁盘中的页，我们称之为脏页。此时<strong>fulsh链表</strong>就是用来记录那些buffer pool中脏页的位置。后期我们只需要定时去刷新fulsh链表，将对应找脏页的数据，刷新到磁盘即可。</p><p><strong>如果buffer pool满了怎么办？</strong></p><p>buffer pool默认的大小默认为128M，我们页的数据为16k，因此buffer pool总会有满的时候，那么后续查询的数据，还会存储到buffer pool中吗？这就要说到Buffer pool的淘汰机制，<strong>lru链表</strong>记录Buffer pool最近访问数据页的地址。每当读取页数据时，都会将该页位置放入lru链表的头部，lru链表本身有长度，当链表满时，lru尾部的数据就会被淘汰。(详情了解lru算法)</p><ul><li>如果淘汰的是脏页，那么需要强制执行checkPoint，将脏页刷入磁盘。</li></ul><p><strong>优化点</strong>：理论上将buffer pool设置到足够大，存储的热点数据越多，效率越高。</p><p><strong>热数据区、冷数据区？</strong></p><p>上面的方式也会产生一个问题。当前用户查询所有数据时，大量的数据导致lru链表节点被频繁淘汰。表扫描只是偶发的行为，但该行为会导致存放的热点数据全部失效，这显然是不合理的。因此Innodb将lru链表一分为二，分为<strong>热数据区、冷数据区</strong>。Innodb将访问到的页节点位置，加入到冷数据区的头部，这个时候热数据区与冷数据区就隔离开了，那么什么时候将页位置节点加入热数据区呢？Innodb制定了规则，新加入节点的时间点  - 上一个节点加入的时间点 &gt; 1秒，则直接加入热数据区。该方式就是为了防止全表扫描对热数据区带来的影响。因为一般频繁的全表扫描，两个节点插入的时间一般小于1秒。</p><p><strong>什么时候Innodb将Buffer pool的脏页数据，持久化到磁盘中？如果中途MySql程序挂了呢？</strong></p><p>InnoDB作为事务数据库采用了<strong>Write Ahead Log</strong>策略：当事务提交时，先写重做日志，再修改页。所以当数据库发生宕机导致脏页的刷新丢失时，可以通过重做日志(redo log)来完成数据的恢复。这便是事务数据库中Durability(持久性)的保证。</p><p>执行update语句时，innodb修改buffer pool数据使页成为脏页，记录到fulsh链表，修改成功之后，生成一个redo.log对象，并存放到log buffer中，如果需要持久化，那么将redo.log持久化，返回客户端修改成功。重启之后会针对redo.log对数据进行修复。redo.log持久化比较快，因为将随机IO转换为顺序IO，这也是为什么不直接修改磁盘数据的原因。</p><p><strong>为什么redo.log有两个文件？</strong></p><p>从官方的图可以看出redo.log有两个文件，logfile0、logfile1。logfile0默认大小为48M,当前logfile存储满后，会切换到logfile1，但是此时logfile0中可能还有未持久化到磁盘的数据，因此当切换redo.log时，Innodb会触发的检查点(Checkpoint)，检查点会检查当前整个buffer pool中与文件中相同的数据，并将数据持久化到页中。</p><p><strong>调优点</strong>：调大logfile的大小和个数，但是调大之后mysql重启恢复数据就会变慢（一般使用中我们很少考虑重启的恢复时间）。</p><p><strong>开启事务的情况下，使用update整个时候需要持久化redo.log吗？</strong></p><p>Innodb提供了三种处理方式：</p><ol><li>事务提交时，不立即去持久化，交给后台线程，此方法缺点在于丢失数据多。</li><li>事务提交时，持久化(默认)，性能最慢，丢失数据少。</li><li>事务提交时，将redo.log写入操作系统的缓冲区，操作系统定时将日志写入硬盘。这种情况下，即时MySql挂了只要操作系统没挂，那么事务的持久化还是能保证。直接断电或者关机的情况下，就会丢失数据。</li></ol><p><a id="changebuffer"><strong>什么是Change Buffer?</strong></a></p><p>前面说了当用户修改数据后，最终会将数据持久化到磁盘中的数据页。但是我们在使用mysql时，还会为MySql建立索引。如果我们修改的数据涉及到索引页，那么也应该将索引页中的数据持久化到磁盘。一张表可能有多个索引页，同时修改这么多的索引页，Innodb又是如何来优化的呢？</p><p>根据Inoodb官方提供的架构图中，可以看到Change Buffer是属于Buffer pool的一部分。Change Buffer默认占Buffer pool中25%的空间。那么Change Buffer作用是什么？</p><p>对于一次更新操作，innodb引擎会看更新的页是否在buffer pool中，如果在，那么直接更新buffer pool，并且写入一条redo log。这样后续的读取操作可以读到最新的值。如果不在，那么就先将本次更新操作记录到Change buffer中，而不是立刻去更新，最后再记录一条redo log。如果后面有读操作，那么再将对应的数据页载入到buffer pool中，同时将change pool中的更新操作应用到该数据页，这个过程叫做merge。当然如果系统是空闲状态，也会有后台线程去做merge过程。</p><p>change buffer仅用于更新<strong>普通索引</strong>，对唯一性索引无效，因为唯一性索引肯定要读数据页做唯一性判断的。</p><p>优化点：在多写少读的情况下，可以将Change Buffer调大(比如日志系统)。</p><p><a id="doublewrite"><strong>Doublewrite buffer是什么？</strong></a></p><p>inndb的16k的数据页，如果写入磁盘中。操作系统中的页数据大小只有4k，因此想要写入操作系统种，那么分四次才能写完。如果在写第二次的时候，操作系统挂掉了，或者机器断电了，最后怎么判断哪些数据改了，那些数据没改呢？ </p><p>因此Innodb将16k的页数据页分四次写入Doublewrite buffer，即使出问题了，也能通过redo.log还原。</p><p>Doublewrite buffer分四次写入磁盘中，中途写失败了，也通过redo.log来还原。</p><p>最后通过Doublewrite buffer分四次写入磁盘的页中，这种方式经历了两次磁盘IO，效率更低，但是为什么要这么做呢？</p><p>主要还是因为磁盘无法支持原子性写入，Doublewrite buffer主要是为了解决，多次写的数据丢失的问题。</p><p>如果从Doublewrite buffer写入到磁盘业数据失败了，也能通过Doublewrite buffer来还原。</p><p><strong>为什么不直接将数据分四次写入磁盘，然后通过redo.log来还原呢？</strong></p><p>redo.log中记录的是对页的物理修改。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。</p><h3 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h3><p>binlog是属于mysql的概念，binlog功能与redo.log类似，也是用来记录mysql的操作，那么为什么Inndb为什么还要设计redo.log呢？</p><p>因为redo.log记录的是某一页中某些数据的物理位置的数据，进行的那些修改，因此在使用redo.log时，Innodb能更快的对数据进行修复。</p><p>而Binlog记录的是执行的语句，因此恢复的效率不如redo.log。</p><p>Binlog本质上是一种逻辑日志，因此能够适用所有的存储引擎，并进行数据复制。</p><p>Binlog与redo.log一样，也是在fulsh链表后进行的持久化。</p><p>Binlog主从复制：</p><p>主从复制的场景中在Master 端会开启binlog ，然后将 binlog 发送到各个Slave 端，Slave 端重放binlog 从而达到Slave 端的数据和Master端的数据保持一致。在数据恢复场景，通过使用mysqlbinlog 工具以及对应的binlog 将数据恢复到指定的时间点。那么可以把binlog 解决的问题总结为两点，就是主从复制和数据恢复。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo_log"></a>undo_log</h3><p>undo_log用于存放不同事务版本下的不同数据，undo_log中记录事务操作前的原始数据，每次数据变更都会产生undolog记录，undo_log记录分为 insert undo_log 和 update undo_log。insert操作属于insert undo_log，只针对当前事务，在insert操作后产生undo_log记录，在事务提交后删除undo_log记录，说白了就是给当前事务自己看的。update 和 delete操作属于update undo_log，会根据隔离级别不同事务版本的数据可见性不同。当事务回滚后，通过undo_log日志内容，将数据还原为原始数据。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><ol><li>联合索引遵循左前缀原则。</li><li>小表 (参与查询数据量小的表) 驱动大表。</li><li>避免使用<code>IS NULL、IS NOT NULL</code> 因为有时候不走索引。</li><li>索引避免进行进操作运算。例如：<code>date(&#39;1970-01-01&#39;)</code></li><li>避免LIKE以%开头的查询，例如 <code>A LIKE &#39;%1&#39;</code>。</li><li>索引列避免隐式转换，例如字段A是一个字符串‘1’，但是查询的时候使用的 A = 1, 虽然也能查到(内部会数值类型的1转换为‘1’)，但是不会走索引。</li><li>使用OR的时候，保证OR的前后都有索引，不然该索引会失效。</li><li>查询的结果尽量保证覆盖索引，避免回表。</li><li>某些时候使用前缀索引可以提高查询效率，但是注意前缀索引不能用于覆盖索引。</li><li>MySql的全文索引不支持中文索引，基本上不会使用，一般使用搜索引擎，例如LUCENE、SOLR、ES。</li><li>对字段进行的操作，都会造成索引失效。</li></ol><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li>不要过度索引。索引越多，占用空间越大，反而性能变慢。</li><li>只对WHERE子句中频繁使用的建立索引。</li><li>尽可能使用唯一索引，重复值越少，索引效果越强。</li><li>使用短索引，如果char(255)太大，应该给它指定一个前缀长度，大部分情况下前10位或20位值基本是唯一的，那么就不要对整个列进行索引。</li><li>充分利用左前缀，这是针对复合索引，因为WHERE语句如果有AND并列，只能识别一个索引(获取记录最少的那个)，索引需要使用复合索引，那么创建时应该将WHERE最频繁的放置在左边。</li><li>索引存在，如果没有满足使用原则，也会导致索引无效。</li></ol><h4 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h4><ol><li>开启查询缓存，优化查询。</li><li>explain你的select查询。</li><li>通过 show status 命令了解各种sql的执行频率,定位执行效率较低的sql语句。</li><li>通过explain分析低效sql的执行计划。</li><li>通过 show profile 分析sql。</li><li>通过trace分析 优化器 如何选择执行计划;确定问题并采取相应的优化措施。</li></ol><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li><strong>Read uncommitted (读未提交)</strong>：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</li><li><strong>Read committed (读已提交)</strong>：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</li><li><strong>Repeatable read (可重复读)</strong>：这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。（当前事务查询的数据，不受其他事务影响）</li><li><strong>Serializable (串行化)</strong>：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC为了提高并发的读写性能，不用加锁就能让多个事务并发读写。InnoDB中，MVCC 是通过 readview + undolog 来实现的。</p><p>在事务中进行写入操作时，会生成一条undo_log日志。日志中记录原数据信息，以及操作数据对应的事务id。undo_log根据日志的先后生成顺序，形成了一条日志记录链表。</p><p>当用户执行查询sql时，会生成一致性视图read-view。它由执行查询时所有未提交事务id数据组和已创建的最大事务id组成。此时我们查询的数据结果需要跟read-view做比对，从undo_log日志中获取快照结果。</p><p>read-view根据生成时间不同，产生了RC,RR两种可见性。</p><p>RC：每条select创建一个新的readview ，所以导致读提交 读到的都是最新提交的。</p><p>RR：事务开始的时候创建一个readview, 一直到事务结束都用的这个readview，也就避免了不可重复读</p><p>事务读数据的原则就是： </p><ul><li><p>读版本号小于等于当前版本的数据(意思就是读不到在当前事务之后修改的数据 避免了不可重复读)</p></li><li><p>读删除事务版本号大于等于当前版本的数据(意思就是如果这条数据在之后的事务里删了，当前事务也不能再读了) </p></li></ul><h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>在日常工作中我们可以通过explain这个命令，来查看某些SQL语句的执行计划，通过执行计划来定位执行中效率较低的SQL。下面是我们</p><table><thead><tr><th align="left">参数</th><th>描述</th></tr></thead><tbody><tr><td align="left">id</td><td>选择标识符，多条语句同时执行的情况下，id值越大优先级越高，越先被执行</td></tr><tr><td align="left">select_type</td><td>查询的类型。</td></tr><tr><td align="left">table</td><td>输出结果集的表</td></tr><tr><td align="left">partitions</td><td>匹配的分区，表分区的时候会用到</td></tr><tr><td align="left">type</td><td>表的连接类型</td></tr><tr><td align="left">possible_keys</td><td>查询时可能使用的索引</td></tr><tr><td align="left">key</td><td>实际使用的索引</td></tr><tr><td align="left">key_len</td><td>索引字段的长度，联合索引情况下，可以推算出运用了那些索引</td></tr><tr><td align="left">ref</td><td>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</td></tr><tr><td align="left">rows</td><td>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</td></tr><tr><td align="left">filtered</td><td>按表条件过滤的行百分比</td></tr><tr><td align="left">Extra</td><td>执行情况的描述和说明</td></tr></tbody></table><p>以下将对explain命令中几个描述较多的参数详细介绍：</p><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><ul><li><strong>SIMPLE</strong>：简单SELECT，不使用UNION或子查询等</li><li><strong>PRIMARY</strong>：子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY</li><li><strong>UNION</strong>：UNION中的第二个或后面的SELECT语句</li><li><strong>DEPENDENT UNION</strong>： UNION中的第二个或后面的SELECT语句，取决于外面的查询</li><li><strong>UNION RESULT</strong>： UNION的结果，union语句中第二个select开始后面所有select</li><li><strong>SUBQUERY</strong>：子查询中的第一个SELECT，结果不依赖于外部查询</li><li><strong>DEPENDENT SUBQUERY</strong>：子查询中的第一个SELECT，依赖于外部查询</li><li><strong>DERIVED</strong>：派生表的SELECT, FROM子句的子查询</li><li><strong>UNCACHEABLE SUBQUERY</strong>：一个子查询的结果不能被缓存，必须重新评估外链接的第一行</li></ul><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul><li><p><strong>ALL</strong>：全表扫描，扫描所有叶子节点。</p></li><li><p><strong>index：index</strong>与ALL区别为index类型只遍历索引树。</p></li><li><p><strong>range</strong>：只搜索给定范围的行，使用一个索引来选择行。</p></li><li><p><strong>ref</strong>: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p></li><li><p><strong>eq_ref</strong>：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。</p></li><li><p><strong>const</strong>、<strong>system</strong>: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system。</p></li><li><p><strong>NULL</strong>：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p></li><li><p><strong>ALL</strong> 一&gt;  <strong>index</strong> 一&gt;  <strong>range</strong> 一&gt;  <strong>ref</strong> 一&gt; <strong>eq_ref</strong>   一&gt;  <strong>const</strong> 一&gt; <strong>system</strong> 一&gt; <strong>NULL</strong>（从左到右，性能从差到好）。</p></li><li><p>日常使用中尽量将SQL优化到range级别。</p></li></ul><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><ul><li><p><strong>Using where</strong>：不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p></li><li><p><strong>Using temporary</strong>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p></li><li><p><strong>Using filesort</strong>：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p></li><li><p><strong>Using join buffer</strong>：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p></li><li><p><strong>Impossible where</strong>：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p></li><li><p><strong>Select tables optimized away</strong>：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p></li><li><p><strong>No tables used</strong>：Query语句中使用from dual 或不含任何from子句</p></li></ul><h3 id="常用命令与设置"><a href="#常用命令与设置" class="headerlink" title="常用命令与设置"></a>常用命令与设置</h3><p><strong>查看查询缓存</strong></p><p><code>show variables like &#39;%query_cache%&#39;;</code>，<code>query_cache_type=NO</code>  表示已经开启）.</p><p><strong>开启查询缓存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;my.cnf</span><br><span class="line">query_cache_size &#x3D; 20M</span><br><span class="line">query_cache_type &#x3D; ON</span><br></pre></td></tr></table></figure><p><strong>重启mysql</strong></p><p><code>service mysql restart</code>。</p><p><strong>查看缓存使用情况</strong></p><p><code>show status like &#39;qcache%&#39;;</code> </p><p>其中各个参数的意义如下：  </p><ul><li><code>Qcache_free_blocks</code>：缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。  </li><li><code>Qcache_free_memory</code>：缓存中的空闲内存。  </li><li><code>Qcache_hits</code>：每次查询在缓存中命中时就增大  </li><li><code>Qcache_inserts</code>：每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。  </li><li><code>Qcache_lowmem_prunes</code>：缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看;如果这个 数字在不断增长，就表示可能碎片非常严重，或者内存很少。(上面的 free_blocks和free_memory可以告诉您属于哪种情况)  </li><li><code>Qcache_not_cached</code>：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。  </li><li><code>Qcache_queries_in_cache</code>：当前缓存的查询(和响应)的数量。  </li><li><code>Qcache_total_blocks</code>：缓存中块的数量。 </li></ul><p>对于某些不想使用缓存的语句，可以这样使用：</p><p><code>select SQL_NO_CACHE count(*) from users where email = &#39;hello&#39;;</code></p><p>参考资料：<a href="https://blog.csdn.net/u010900754/article/details/106744734">https://blog.csdn.net/u010900754/article/details/106744734</a></p><p>​                    <a href="https://www.cnblogs.com/ttaall/p/14339130.html">https://www.cnblogs.com/ttaall/p/14339130.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;title: mysql总结&lt;/p&gt;
&lt;p&gt;author: yingu&lt;/p&gt;
&lt;p&gt;thumbnail: &lt;a href=&quot;http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/cs/cs-20.jpg&quot;&gt;http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/cs/cs-20.jpg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;toc: true &lt;/p&gt;
&lt;p&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;工具&lt;/li&gt;
&lt;li&gt;数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;categories: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[工具,mysql] &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;date: 2020-05-04 13:15:42&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h3&gt;&lt;p&gt;MySql支持多种存储引擎，通过navicat新建表可以看到，MySql一共支持7种存储引擎。我们平时听到最多的MyISAM与InnoDB就在其中。MyISAM是5.1版本之前的默认引擎，5.1之后InnoDB就成为了Mysql的默认引擎，一直沿用至今。那么这两种引擎之间有什么区别呢？
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>redis总结</title>
    <link href="https://yingu.site/2020/05/04/RedisSummary/"/>
    <id>https://yingu.site/2020/05/04/RedisSummary/</id>
    <published>2020-05-04T05:15:42.000Z</published>
    <updated>2021-07-18T12:31:14.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>常用命令: <code>set,get,decr,incr,mget</code> 等。</p><p>特点：redis种最常用的一种数据结构</p><p>应用场景： 通过String的bitmap可以实现：布隆过滤器、AO权限、用户签到、活跃用户、用户在线状态。</p><p>通过自增、自减实现计数器、分布式锁</p><a id="more"></a><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>常用命令：<code>hget,hset,hgetall</code>等</p><p>特点：存放的是结构化的对象，可以对对象中属性单独修改</p><p>应用场景：比较适合存储一些详情信息、例如购物车、对象</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>常用命令：<code>lpush,rpush,lpop,rpop,lrange</code>等</p><p>特点：链表，按照插入顺序排序</p><p>应用场景：消息队列、最新列表、排行榜(定时计算)、利用lrange命令做分页</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>常用命令： <code>sadd,spop,smembers,sunion</code> 等</p><p>特点：不可重复、无序</p><p>应用场景：通过交集实现共同好友功能、通过差集实现推荐好友功能、去重</p><h3 id="zset-sorted-set"><a href="#zset-sorted-set" class="headerlink" title="zset(sorted set)"></a>zset(sorted set)</h3><p>特点：可以通过权重参数score来对set中的元素进行排序</p><p>应用场景：排行榜(实时计算)、评论+动态分页</p><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>通过定时器监听所有key的过期，可以立即清除过期的key但是比较占用CPU资源，如果有大量的key需要清除，那么可能会影响数据的读写效率</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>当访问指定key时，才会检测key是否需要清除，如果大量过期的key没有被访问到，那么会占用大量内存</p><h3 id="定期过期"><a href="#定期过期" class="headerlink" title="定期过期"></a>定期过期</h3><p>每隔一定的时间，执行一次删除过期key操作。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p><p><strong>redis默认使用定期删除+惰性删除策略</strong>：redis默认每100ms随机对redis中key进行检查，如果key过期那么删除，未删除的key在下一次使用时，会通过惰性删除策略检查并删除。如果用户一直不访问未被删除的key，那么最后过期的key会越来越多，那么此时就该采用<strong>内存淘汰策略</strong>了。</p><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><h3 id="noeviction"><a href="#noeviction" class="headerlink" title="noeviction"></a>noeviction</h3><p>当内存不足以容纳新写入数据时，新写入操作会报错。</p><h3 id="allkeys-lru"><a href="#allkeys-lru" class="headerlink" title="allkeys-lru"></a>allkeys-lru</h3><p>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</p><h3 id="allkeys-random"><a href="#allkeys-random" class="headerlink" title="allkeys-random"></a>allkeys-random</h3><p>当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</p><h3 id="volatile-lru"><a href="#volatile-lru" class="headerlink" title="volatile-lru"></a>volatile-lru</h3><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</p><h3 id="volatile-random"><a href="#volatile-random" class="headerlink" title="volatile-random"></a>volatile-random</h3><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</p><h3 id="volatile-ttl"><a href="#volatile-ttl" class="headerlink" title="volatile-ttl"></a>volatile-ttl</h3><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><p>​        <code>redis</code>默认提供以上六种策略，用户可以通过<code>redis.conf</code>中的<code>maxmemory-policy</code>来配置，例如：<code>maxmemory-policy allkeys-lru</code>。如果没有设置 <code>expire</code> 的<code>key</code>, 那么 <code>volatile-lru</code>, <code>volatile-random</code> 和 <code>volatile-ttl</code> 策略的行为和 <code>noeviction</code>基本上一致。</p><h2 id="缓存穿透、缓存击穿、缓存雪崩"><a href="#缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩"></a>缓存穿透、缓存击穿、缓存雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>特点：去请求缓存中不存在的数据，导致所有的请求都打到数据库，从而造成数据库连接异常。</p><p>解决方案：</p><ol><li>布隆过滤器：内部维护数据库中所有数据的key，通过判断请求key是否有效，来决定是否需要去数据库中查询。</li><li>异步更新：无论key是否存在都返回，随后另开一个线程异步去数据库中查询。</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>特点：缓存穿透的一种情况，当前一条数据失效。(单个key请求量较大)</p><p>解决方案：如果当前数据不是热点数据且访问量小那么不需要解决，如果为热点数据或访问量大，那么可以通过分布式锁来解决。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>特点：缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都打到数据库上，从而导致数据库连接异常。</p><p>解决方案：给缓存的失效时间，加上一个随机值，避免集体失效。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<strong>redis默认开启</strong>。</p><p>优点：恢复速度快、使用单独的子线程进行持久化，主进程不会进行任何IO操作</p><p>缺点：持久化之间发生故障后丢失的数据较多</p><p>参数配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#dbfilename：持久化数据存储在本地的文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">#dir：持久化数据存储在本地的路径，如</span><br><span class="line">dir .&#x2F;</span><br><span class="line">##snapshot触发的时机，save     </span><br><span class="line">#在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</span><br><span class="line">save 900 1   </span><br><span class="line"> #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</span><br><span class="line">save 300 10</span><br><span class="line">#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br><span class="line">save 60 10000</span><br><span class="line">##当snapshot时出现错误无法继续时，是否阻塞客户端&quot;变更操作&quot;，&quot;错误&quot;可能因为磁盘已满&#x2F;磁盘故障&#x2F;OS级别异常等  </span><br><span class="line">stop-writes-on-bgsave-error yes  </span><br><span class="line">##是否启用rdb文件压缩，默认为&quot;yes&quot;，压缩往往意味着&quot;额外的cpu消耗&quot;，同时也意味这较小的文件尺寸以及较短的网络传输时间  </span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><p>优点：持久化之间发生故障后丢失数据少</p><p>缺点：恢复速度较慢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##此选项为aof功能的开关，默认为&quot;no&quot;，可以通过&quot;yes&quot;来开启aof功能  </span><br><span class="line">##只有在&quot;yes&quot;下，aof重写&#x2F;文件同步等特性才会生效  </span><br><span class="line">appendonly yes  </span><br><span class="line"> </span><br><span class="line">##指定aof文件名称  </span><br><span class="line">appendfilename appendonly.aof  </span><br><span class="line"> </span><br><span class="line">##指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  </span><br><span class="line">appendfsync everysec  </span><br><span class="line">##在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示&quot;不暂缓&quot;，&quot;yes&quot;表示&quot;暂缓&quot;，默认为&quot;no&quot;  </span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"> </span><br><span class="line">##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认&quot;64mb&quot;，建议&quot;512mb&quot;  </span><br><span class="line">auto-aof-rewrite-min-size 64mb  </span><br><span class="line"> </span><br><span class="line">##相对于&quot;上一次&quot;rewrite，本次rewrite触发时aof文件应该增长的百分比。  </span><br><span class="line">##每一次rewrite之后，redis都会记录下此时&quot;新aof&quot;文件的大小(例如A)，那么当aof文件增长到A*(1 + p)之后  </span><br><span class="line">##触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  </span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line"></span><br><span class="line">AOF 是文件操作，对于变更操作比较密集的 server，那么必将造成磁盘 IO 的负荷加重；此外 linux 对文件操作采取了“延迟写入”手段，即并非每次 write 操作都会触发实际磁盘操作，而是进入了 buffer 中，当 buffer 数据达到阀值时触发实际写入(也有其他时机)，这是 linux 对文件系统的优化，但是这却有可能带来隐患，如果 buffer 没有刷新到磁盘，此时物理机器失效(比如断电)，那么有可能导致最后一条或者多条 aof 记录的丢失。通过上述配置文件，可以得知 redis 提供了 3 中 aof 记录同步选项：</span><br><span class="line">always：每一条 aof 记录都立即同步到文件，这是最安全的方式，也以为更多的磁盘操作和阻塞延迟，是 IO 开支较大。</span><br><span class="line">everysec：每秒同步一次，性能和安全都比较中庸的方式，也是 redis 推荐的方式。如果遇到物理服务器故障，有可能导致最近一秒内 aof 记录丢失(可能为部分丢失)。</span><br><span class="line">no：redis 并不直接调用文件同步，而是交给操作系统来处理，操作系统可以根据 buffer 填充情况 &#x2F; 通道空闲时间等择机触发同步；这是一种普通的文件操作方式。性能较好，在物理服务器故障时，数据丢失量会因 OS 配置有关。</span><br></pre></td></tr></table></figure><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>Redis 4.0 开始支持 rdb 和 aof 的混合持久化(默认关闭)。如果把混合持久化打开，<code>aof rewrite</code> 的时候就直接把 rdb 的内容写到 aof 文件开头。也就是说日志只用来做增量恢复， 而快照用来使用恢复。打开混合持久化的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="主从复制-Replication"><a href="#主从复制-Replication" class="headerlink" title="主从复制(Replication)"></a>主从复制(Replication)</h3><p>当你的业务需要对redis进行大量读请求，而你的redis服务器性能又不够时，就可以通过主从复制的方式对redis进行一个集群配置。</p><p>特点：</p><ol><li>读写分离：master提供读写服务，slave(可以为多个)提供读服务</li><li>master挂了后，无法自动重新选举master,那么此时无法提供写服务</li></ol><p>Redis的主从复制可以根据是否全量分为全量同步和增量同步。</p><p>主从复制的过程：</p><p>​        <code>redis</code>的主从复制策略是通过其持久化的RDB文件来实现的，当配置好<code>Slave</code>后，<code>Slave</code>与<code>Master</code>建立连接，然后发送sync命令。无论是第一次连接还是重新连接，<code>Master</code>都会启动一个后台进 程，将数据库RDB快照保存到文件中，同时<code>Master</code>主进程会开始收集新的写命令并缓存。后台进程完成写文件后，<code>Master</code>就发送文件给  <code>Slave</code>，<code>Slave</code>将文件保存到硬盘上，再加载到内存中，接着<code>Master</code>就会把缓存的命令转发给<code>Slave</code>，后续<code>Master</code>将收到的写命令发送给 <code>Slave</code>。如果<code>Master</code>同时收到多个<code>Slave</code>发来的同步连接命令，<code>Master</code>只会启动一个进程来写数据库镜像，然后发送给所有的<code>Slave</code>。</p><p><code>redis.conf</code>参数配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Master节点中配置读写分离 slave-read-only yes</span><br><span class="line">Slave节点中配置 slaveof master_ip master_port 6379 #指定master的ip和端口</span><br></pre></td></tr></table></figure><h3 id="哨兵模式-Sentinel"><a href="#哨兵模式-Sentinel" class="headerlink" title="哨兵模式(Sentinel)"></a>哨兵模式(Sentinel)</h3><p> Redis从2.8开始正式提供了<code>Redis Sentinel</code> 架构，<code>Sentinel</code>用于监控redis集群中<code>Master</code>主服务器工作的状态，当前<code>Master</code>发生故障后，可以实现Master和Slave服务器的切换。</p><p>工作方式：</p><ol><li>每个<code>Sentinel</code>以每秒钟一次的频率向它所知的<code>Master</code>，<code>Slave</code>以及其他 <code>Sentinel</code> 实例发送一个PING命令。</li><li>如果一个实例（instance）距离最后一次有效回复PING命令的时间超过 <code>own-after-milliseconds</code> 选项所指定的值，则这个实例会被<code>Sentinel</code>标记为主观下线。 </li><li>如果一个<code>Master</code>被标记为主观下线，则正在监视这个<code>Master</code>的所有 <code>Sentinel</code> 要以每秒一次的频率确认<code>Master</code>的确进入了主观下线状态。 </li><li>当有足够数量的<code>Sentinel</code>（大于等于配置文件指定的值）在指定的时间范围内确认<code>Master</code>的确进入了主观下线状态，则<code>Master</code>会被标记为客观下线。</li><li>在一般情况下，每个<code>Sentinel</code> 会以每10秒一次的频率向它已知的所有Master，<code>Slave</code>发送 INFO 命令。</li><li>当Master被Sentinel标记为客观下线时，<code>Sentinel</code> 向下线的 <code>Master</code> 的所有<code>Slave</code>发送 INFO命令的频率会从10秒一次改为每秒一次。 </li><li>若没有足够数量的<code>Sentinel</code>同意<code>Master</code>已经下线，Master的客观下线状态就会被移除。 若 <code>Master</code>重新向<code>Sentinel</code> 的PING命令返回有效回复，Master的主观下线状态就会被移除。</li></ol><p>哨兵的主要功能</p><ul><li><p>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</p></li><li><p>消息通知：如果某个 <strong>Redis</strong> 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p></li><li><p>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</p></li><li><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p></li></ul><p><code>sentinel.conf</code> 参数配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"></span><br><span class="line"># *** IMPORTANT ***</span><br><span class="line"># 绑定IP地址</span><br><span class="line"># bind 127.0.0.1 192.168.1.1</span><br><span class="line"># 保护模式（是否禁止外部链接，除绑定的ip地址外）</span><br><span class="line"># protected-mode no</span><br><span class="line"></span><br><span class="line"># port &lt;sentinel-port&gt;</span><br><span class="line"># 此Sentinel实例运行的端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 默认情况下，Redis Sentinel不作为守护程序运行。 如果需要，可以设置为 yes。</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># 启用守护进程运行后，Redis将在&#x2F;var&#x2F;run&#x2F;redis-sentinel.pid中写入一个pid文件</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-sentinel.pid</span><br><span class="line"></span><br><span class="line"># 指定日志文件名。 如果值为空，将强制Sentinel日志标准输出。守护进程下，如果使用标准输出进行日志记录，则日志将发送到&#x2F;dev&#x2F;null</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># sentinel announce-ip &lt;ip&gt;</span><br><span class="line"># sentinel announce-port &lt;port&gt;</span><br><span class="line">#</span><br><span class="line"># 上述两个配置指令在环境中非常有用，因为NAT可以通过非本地地址从外部访问Sentinel。</span><br><span class="line">#</span><br><span class="line"># 当提供announce-ip时，Sentinel将在通信中声明指定的IP地址，而不是像通常那样自动检测本地地址。</span><br><span class="line">#</span><br><span class="line"># 类似地，当提供announce-port 有效且非零时，Sentinel将宣布指定的TCP端口。</span><br><span class="line">#</span><br><span class="line"># 这两个选项不需要一起使用，如果只提供announce-ip，Sentinel将宣告指定的IP和“port”选项指定的服务器端口。</span><br><span class="line"># 如果仅提供announce-port，Sentinel将通告自动检测到的本地IP和指定端口。</span><br><span class="line">#</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># sentinel announce-ip 1.2.3.4</span><br><span class="line"></span><br><span class="line"># dir &lt;working-directory&gt;</span><br><span class="line"># 每个长时间运行的进程都应该有一个明确定义的工作目录。对于Redis Sentinel来说，&#x2F;tmp就是自己的工作目录。</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"></span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">#</span><br><span class="line"># 告诉Sentinel监听指定主节点，并且只有在至少&lt;quorum&gt;哨兵达成一致的情况下才会判断它 O_DOWN 状态。</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># 副本是自动发现的，因此您无需指定副本。</span><br><span class="line"># Sentinel本身将重写此配置文件，使用其他配置选项添加副本。另请注意，当副本升级为主副本时，将重写配置文件。</span><br><span class="line">#</span><br><span class="line"># 注意：主节点（master）名称不能包含特殊字符或空格。</span><br><span class="line"># 有效字符可以是 A-z 0-9 和这三个字符 &quot;.-_&quot;.</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"># 如果redis配置了密码，那这里必须配置认证，否则不能自动切换</span><br><span class="line"># Example:</span><br><span class="line">#</span><br><span class="line"># sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">#</span><br><span class="line"># 主节点或副本在指定时间内没有回复PING，便认为该节点为主观下线 S_DOWN 状态。</span><br><span class="line">#</span><br><span class="line"># 默认是30秒</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;</span><br><span class="line">#</span><br><span class="line"># 在故障转移期间，多少个副本节点进行数据同步</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">#</span><br><span class="line"># 指定故障转移超时（以毫秒为单位）。 它以多种方式使用：</span><br><span class="line">#</span><br><span class="line"># - 在先前的故障转移之后重新启动故障转移所需的时间已由给定的Sentinel针对同一主服务器尝试，是故障转移超时的两倍。</span><br><span class="line">#</span><br><span class="line"># - 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="line">#</span><br><span class="line"># - 取消已在进行但未生成任何配置更改的故障转移所需的时间</span><br><span class="line">#</span><br><span class="line"># - 当进行failover时，配置所有slaves指向新的master所需的最大时间。</span><br><span class="line">#   即使过了这个超时，slaves依然会被正确配置为指向master。</span><br><span class="line">#</span><br><span class="line"># 默认3分钟</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"># 脚本执行</span><br><span class="line">#</span><br><span class="line"># sentinel notification-script和sentinel reconfig-script用于配置调用的脚本，以通知系统管理员或在故障转移后重新配置客户端。</span><br><span class="line"># 脚本使用以下规则执行以进行错误处理：</span><br><span class="line">#</span><br><span class="line"># 如果脚本以“1”退出，则稍后重试执行（最多重试次数为当前设置的10次）。</span><br><span class="line">#</span><br><span class="line"># 如果脚本以“2”（或更高的值）退出，则不会重试执行。</span><br><span class="line">#</span><br><span class="line"># 如果脚本因为收到信号而终止，则行为与退出代码1相同。</span><br><span class="line">#</span><br><span class="line"># 脚本的最长运行时间为60秒。 达到此限制后，脚本将以SIGKILL终止，并重试执行。</span><br><span class="line"></span><br><span class="line"># 通知脚本</span><br><span class="line">#</span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">#</span><br><span class="line"># 为警告级别生成的任何Sentinel事件调用指定的通知脚本（例如-sdown，-odown等）。</span><br><span class="line"># 此脚本应通过电子邮件，SMS或任何其他消息传递系统通知系统管理员 监控的Redis系统出了问题。</span><br><span class="line">#</span><br><span class="line"># 使用两个参数调用脚本：第一个是事件类型，第二个是事件描述。</span><br><span class="line">#</span><br><span class="line"># 该脚本必须存在且可执行，以便在提供此选项时启动sentinel。</span><br><span class="line">#</span><br><span class="line"># 举例:</span><br><span class="line">#</span><br><span class="line"># sentinel notification-script mymaster &#x2F;var&#x2F;redis&#x2F;notify.sh</span><br><span class="line"></span><br><span class="line"># 客户重新配置脚本</span><br><span class="line">#</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">#</span><br><span class="line"># 当主服务器因故障转移而变更时，可以调用脚本执行特定于应用程序的任务，以通知客户端，配置已更改且主服务器地址已经变更。</span><br><span class="line">#</span><br><span class="line"># 以下参数将传递给脚本：</span><br><span class="line">#</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line">#</span><br><span class="line"># &lt;state&gt; 目前始终是故障转移 &quot;failover&quot;</span><br><span class="line"># &lt;role&gt; 是 &quot;leader&quot; 或 &quot;observer&quot;</span><br><span class="line">#</span><br><span class="line"># 参数 from-ip, from-port, to-ip, to-port 用于传递主服务器的旧地址和所选副本的新地址。</span><br><span class="line">#</span><br><span class="line"># 举例:</span><br><span class="line">#</span><br><span class="line"># sentinel client-reconfig-script mymaster &#x2F;var&#x2F;redis&#x2F;reconfig.sh</span><br><span class="line"></span><br><span class="line"># 安全</span><br><span class="line"># 避免脚本重置，默认值yes</span><br><span class="line"># 默认情况下，SENTINEL SET将无法在运行时更改notification-script和client-reconfig-script。</span><br><span class="line"># 这避免了一个简单的安全问题，客户端可以将脚本设置为任何内容并触发故障转移以便执行程序。</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br><span class="line"></span><br><span class="line"># REDIS命令重命名</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># 在这种情况下，可以告诉Sentinel使用不同的命令名称而不是正常的命令名称。</span><br><span class="line"># 例如，如果主“mymaster”和相关副本的“CONFIG”全部重命名为“GUESSME”，我可以使用：</span><br><span class="line">#</span><br><span class="line"># SENTINEL rename-command mymaster CONFIG GUESSME</span><br><span class="line">#</span><br><span class="line"># 设置此类配置后，每次Sentinel使用CONFIG时，它将使用GUESSME。 请注意，实际上不需要尊重命令案例，因此在上面的示例中写“config guessme”是相同的。</span><br><span class="line">#</span><br><span class="line"># SENTINEL SET也可用于在运行时执行此配置。</span><br><span class="line">#</span><br><span class="line"># 为了将命令设置回其原始名称（撤消重命名），可以将命令重命名为它自身：</span><br><span class="line">#</span><br><span class="line"># SENTINEL rename-command mymaster CONFIG CONFIG</span><br></pre></td></tr></table></figure><h3 id="Redis-Sharding-客户端分片"><a href="#Redis-Sharding-客户端分片" class="headerlink" title="Redis Sharding(客户端分片)"></a>Redis Sharding(客户端分片)</h3><p>redis 3.0以下使用<strong>客户端sharding</strong>分片技术，它是一主多备的实现方式。采用一致性Hash算法来实现数据的分片。通过将数据分散到多个Redis实例中，进而减轻单台redis实例的压力。</p><p>优点：服务端独立，降低了服务器集群的复杂性、减轻单台redis实例的压力、横向扩展可存储更多数据</p><p>缺点：需要实时获取集群节点的联系信息，动态添加节点需要客户端支持动态sharding，并且需要重启服务器</p><h3 id="Redis-Cluster-服务端分片"><a href="#Redis-Cluster-服务端分片" class="headerlink" title="Redis-Cluster(服务端分片)"></a>Redis-Cluster(服务端分片)</h3><p>redis 3.0推出的Redis-Cluster是基于Redis Sharding的一种集群方式。一个Redis Cluster由多个Redis节点组成。不同的节点组服务的数据无交集，每个节点对应数据sharding的一个分片。节点组内部分为主备2类，对应前面叙述的master和slave。两者数据准实时一致，通过异步化的主备复制机制保证。一个节点组有且仅有一个master，同时有0到多个slave。只有master对外提供写服务，读服务可由master/slave提供。</p><p>原理：redis cluster 默认分配了 16384(2^14) 个slot，当我们set一个key  时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) %  16384。必须要3个以上的主节点，否则在创建集群时会失败。</p><ul><li>为什么RedisCluster有16384个槽？CRC16算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做mod运算的时候，为什么不mod65536，而选择mod16384？<ol><li>因为节点在通讯的时候会携带消息头。如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。</li><li>一般情况下节点不会超过1000个，因此16384个槽位足够我们使用。</li><li>如果节点太少，而槽位有很多的情况下，压缩效率较低。</li></ol></li></ul><h4 id="Redis-Cluster原理"><a href="#Redis-Cluster原理" class="headerlink" title="Redis Cluster原理"></a>Redis Cluster原理</h4><ol><li>node1和node2首先进行握手meet，知道彼此的存在</li><li>握手成功后，两个节点会定期发送ping/pong消息，交换数据信息(消息头，消息体)</li><li>消息头里面有个字段：unsigned char myslots[CLUSTER_SLOTS/8]，每一位代表一个槽，如果该位是1，代表该槽属于这个节点</li><li>消息体中会携带一定数量的其他节点的信息，大约占集群节点总数量的十分之一，至少是3个节点的信息。节点数量越多，消息体内容越大。</li><li>每秒都在发送ping消息。每秒随机选取5个节点，找出最久没有通信的节点发送ping消息。</li><li>每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2,则立即发送ping消息</li></ol><h2 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h2><p>一致性hash算法是基于hash算法实现的，<code>Redis Sharding</code>使用了此算法。</p><p>原理：首先求出服务器的哈希值，并将其映射到0~2^32个槽的圆环上。不同的服务器经过hash计算后，分配到圆环上不同的槽。当用户存储数据时，也会通过计算数据键的哈希值的方式将数据映射到圆环上，接着从数据映射的位置开始顺时针查找，将数据保存到找到的第一个服务器上，如果找了一圈还没找到，那么最就会保存到第一台服务器上。</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95.png" alt=""></p><p>一致性hash算法的好处很明显，当需要新增节点时只会影响顺时针的下一个节点，但是这种方式也会带来一种问题，那么就是数据倾斜，如图：</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95%E5%80%BE%E6%96%9C.png" alt=""></p><p>从上面图就可以看出，当服务器分布不均时，可能会导致大量的数据存储到同一个数据库中，产生一个数据倾斜的问题，因此为了解决这种问题，一致性hash算法引入了虚拟节点机制，即对每一个服务器节点计算多个hash，将每个计算结果都放置一个此服务器节点，称为虚拟节点。实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p><h2 id="常见优化"><a href="#常见优化" class="headerlink" title="常见优化"></a>常见优化</h2><ol><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>为什么redis采用单线程？</li></ul><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。并且单线程更容易实现，不用考虑线程切换消耗性能的问题，也就不需要考虑线程安全问题。</p><p>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p><ul><li>Redis如何做内存优化？</li></ul><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p><p>参考资料</p><p><a href="https://www.jianshu.com/p/65765dd10671">https://www.jianshu.com/p/65765dd10671</a></p><p><a href="https://blog.csdn.net/u010647035/article/details/90553596">https://blog.csdn.net/u010647035/article/details/90553596</a></p><p><a href="https://www.cnblogs.com/williamjie/p/9477852.html">https://www.cnblogs.com/williamjie/p/9477852.html</a></p><p><a href="https://blog.csdn.net/fouy_yun/article/details/81590252">https://blog.csdn.net/fouy_yun/article/details/81590252</a></p><p><a href="https://www.cnblogs.com/Eugene-Jin/p/10819601.html">https://www.cnblogs.com/Eugene-Jin/p/10819601.html</a></p><p><a href="https://blog.csdn.net/qq_41453285/article/details/106383157">https://blog.csdn.net/qq_41453285/article/details/106383157</a></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h3&gt;&lt;p&gt;常用命令: &lt;code&gt;set,get,decr,incr,mget&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;特点：redis种最常用的一种数据结构&lt;/p&gt;
&lt;p&gt;应用场景： 通过String的bitmap可以实现：布隆过滤器、AO权限、用户签到、活跃用户、用户在线状态。&lt;/p&gt;
&lt;p&gt;通过自增、自减实现计数器、分布式锁&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://yingu.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="redis" scheme="https://yingu.site/categories/%E5%B7%A5%E5%85%B7/redis/"/>
    
    
      <category term="工具" scheme="https://yingu.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="redis" scheme="https://yingu.site/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用Docker启动常用工具</title>
    <link href="https://yingu.site/2020/05/03/DockerTools/"/>
    <id>https://yingu.site/2020/05/03/DockerTools/</id>
    <published>2020-05-03T11:12:55.000Z</published>
    <updated>2021-07-18T12:31:14.983Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下配置说明都是基于windows系统</strong></p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><ol><li><p><code>docker search 镜像名</code> ：搜索一个指定的镜像。例如<code>docker search redis</code>,可能会搜索出多个，但是一般选择第一个，也就是starts数最高的一个。<a id="more"></a></p></li><li><p><code>docker pull 镜像:版本号</code>: 拉取一个镜像到本地的docker仓库，如果未选择版本号，那么默认使用镜像的最新版本。例如<code>docker pull redis</code>默认会拉取名为<code>redis:latest</code>的镜像，<code>docker pull redis:6.0</code>会拉拉取一个<code>redis 6.0</code>版本的镜像。想知道具体有哪些版本的可以去<a href=""https://hub.docker.com"">DockerHub</a>中查看。</p></li><li><p><code>docker images</code>:查看当前容器的所有镜像，如果刚才使用了<code>docker pull redis</code>命令来拉取，那么此时我们本地仓库中应该就有一个<code>redis</code>镜像。<code>REPOSITORY</code>表示资源，<code>IMAGE_ID</code>就表示镜像的ID，<code>TAG</code>表示镜像的版本，我们也可以将<code>TAG</code>修改为我们自己习惯的标签。</p></li><li><p><code>docker run -itd -v  宿主机目录:容器目录 -p 宿主机端口:容器端口  --name 容器名 --restart=always 镜像ID</code> ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v &#x2F;C&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;C&#x2F;redis&#x2F;data:&#x2F;data -p 6379:6379 --name redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --restart&#x3D;always redis</span><br></pre></td></tr></table></figure><p>通过<code>docker run</code>命令启动一个容器：</p><ul><li><code>-i</code>  ：以交互模式运行容器，通常与 -t 同时使用。</li><li><code>-t</code>：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li><li><code>-d</code> ：后台运行容器，并返回容器ID</li><li><code>-e</code> ：传递环境变量</li><li>上面三个命令可以写到一起也就是上面的<code>-itd</code>，当然你也可以<code>-i -t -d</code></li><li><code>-v</code> ：挂载宿主机的一个目录，上面就是将容器中<code>/etc/redis/redis.conf</code>的文件挂载到我本机的C盘下redis目录下的<code>redis.conf</code>文件，同理<code>/C/redis/data:/data</code>就是将容器中的/data目录挂载到C盘下的<code>/redis/data</code>目录中。</li><li><code>-p</code>：映射一个端口，本机上可以通过映射的端口访问到容器的端口</li><li><code>--name</code>：为启动的容器起一个名称</li><li><code>--restart=always</code>：表示是否随docker启动，类似于windows中的一个开机启动。如果未设置那么默认为不随docker启动</li><li><code>IMAGE_ID</code> ：表示通过指定镜像启动的容器，上面命令中是通过REPOSITORY来启动的，效果跟直接使用<code>IMAGE_ID</code> 一样，通过<code>REPOSITORY:TAG</code>的方式可以确定一个镜像，上面未指定TAG默认为<code>redis:latest</code>。</li></ul></li><li><p><code>docker ps</code>：查看运行中的容器，如果通过<code>docker run</code>启动成功后，就有一个名为 redis-server的容器了，<code>CONTAINER ID</code>表示容器ID，<code>IMAGE</code>表示基于哪一个镜像启动的。</p></li><li><p><code>docker ps -a</code>：查看所有容器</p></li><li><p><code>docker exec -it 容器ID /bin/bash</code>：表示在运行的容器中执行命令</p></li><li><p><code>docker cp 容器ID:目录路径 宿主机路径</code>：将容器中指定目录文件拷贝到宿主机目录中</p></li><li><p><code>docker cp 宿主机路径 容器ID:目录路径</code>：将宿主机目录的文件拷贝到容器中</p></li><li><p><code>docker stop 容器ID</code>：停止一个容器</p></li><li><p><code>docker start 容器ID</code>: 启动一个容器</p></li><li><p><code>docker restart 容器ID</code>：重启一个容器</p></li><li><p><code>docker rm 容器ID</code>：删除一个容器</p></li><li><p><code>docker rmi 镜像ID</code>：删除一个镜像，如果镜像下面有容器，会提示无法删除，如果强制删除添加-f</p></li><li><p><code>docker commit -a 提交人 -m 备注 容器ID 仓库名:标签</code>：将容器提交为一个镜像。例如：<code>docker commit -m &#39;commit images&#39; -a &#39;zhangsan&#39;  9adeb59430256  redis:test</code></p></li><li><p><code>docker load -i myredis.tar</code>:将宿主机的<code>myredis.tar</code>加载到docker中，加载成功后docker中会多一个刚才导入的镜像</p></li><li><p><code>docker save -o es.tar redis:test1 redis:test2</code>:将docker中的多个镜像打包到宿主机中</p></li><li><p><code>docker logs  --since 30m 容器ID</code>：查询指定容器30分钟内的日志</p></li></ol><h2 id="Docker启动portainer"><a href="#Docker启动portainer" class="headerlink" title="Docker启动portainer"></a>Docker启动portainer</h2><p><code>Portainer</code>是<code>Docker</code>的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作。启动命令：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">9000</span>:<span class="number">9000</span> -v /<span class="keyword">var</span>/run/docker.sock:/<span class="keyword">var</span>/run/docker.sock -v /C/portainer:/data --name portainer-server --restart=always portainer/portainer</span><br></pre></td></tr></table></figure><ul><li><code>-v /var/run/docker.sock:/var/run/docker.sock</code>：加上此设置表示本地模式，不加表示远程模式。</li><li><code>-v /C/portainer:/data</code>：将<code>portainer</code>的数据目录映射到本机中。</li></ul><p>如果是在windows中使用<code>portainer</code>,由于<code>portainer</code>是在容器中，此时<code>portainer</code>想管理宿主机中的<code>docker</code>服务，就必须将宿主机的端口暴露出来，让<code>portainer</code>访问。</p><ol><li>右键docker图标打开setting-&gt;General会看到<code>Expose daemon on tcp://localhost:2375 without TLS</code>选项，将这个设置勾上即可。</li><li>通过<a href="http://localhost:9000访问到`portainer`后，如果是第一次访问需要先设置密码，登陆后在`Remote`标签页`EndPoint">http://localhost:9000访问到`portainer`后，如果是第一次访问需要先设置密码，登陆后在`Remote`标签页`EndPoint</a> Url<code>处填上</code>docker.for.win.localhost:2375<code>，</code>name<code>自己随便取个名，然后点击</code>Connect`按钮即可。</li></ol><h2 id="Docker启动redis"><a href="#Docker启动redis" class="headerlink" title="Docker启动redis"></a>Docker启动redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v &#x2F;C&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;C&#x2F;redis&#x2F;data:&#x2F;data -p 6379:6379 --name redis-server --restart&#x3D;always redis &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes</span><br></pre></td></tr></table></figure><ul><li><code>-v /C/redis/redis.conf:/etc/redis/redis.conf</code>：将redis的配置映射出来，这样每次修改配置通过本机即可</li><li><code>-v /C/redis/data:/data</code>：将redis中的数据目录映射出来，避免误删容器导致数据丢失。</li><li><code>--appendonly yes</code>：打开redis持久化配置</li><li><code>--restart=always</code>：随容器启动</li></ul><h2 id="Docker启动nginx"><a href="#Docker启动nginx" class="headerlink" title="Docker启动nginx"></a>Docker启动nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 80:80 -v &#x2F;C&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v &#x2F;C&#x2F;nginx&#x2F;conf.d&#x2F;default.conf -v &#x2F;C&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx --name nginx-server nginx</span><br><span class="line">--restart&#x3D;always</span><br></pre></td></tr></table></figure><ul><li><code>-v /C/nginx/nginx.conf:/etc/nginx/nginx.conf</code>：将nginx的配置文件映射出来</li><li><code>-v /C/nginx/log:/var/log/nginx</code>：将日志映射出来</li><li><code>--restart=always</code>：随容器启动</li></ul><h2 id="Docker启动mysql"><a href="#Docker启动mysql" class="headerlink" title="Docker启动mysql"></a>Docker启动mysql</h2><p>此处使用5.7版本，8.0版本需要设置加密方式比较麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 3307:3306 -v &#x2F;C&#x2F;mysql&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;my.cnf -v &#x2F;C&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql --name mysql-server -e MYSQL_ROOT_PASSWORD&#x3D;123456  </span><br><span class="line">--restart&#x3D;always mysql:5.7</span><br></pre></td></tr></table></figure><ul><li><code>-v /C/mysql/my.cnf:/etc/mysql/my.cnf</code>：将<code>mysql</code>的配置文件映射出来</li><li><code>-v /C/mysql/data:/var/lib/mysql</code>：将<code>mysql</code>的数据目录映射出来</li><li><code>-e MYSQL_ROOT_PASSWORD=123456</code>：首次启动时需要指定root密码</li><li><code>--restart=always</code>：随容器启动</li></ul><h2 id="Docker启动rabbitmq"><a href="#Docker启动rabbitmq" class="headerlink" title="Docker启动rabbitmq"></a>Docker启动rabbitmq</h2><p><code>docker search rabbitmq:3.7.7-management</code>这种是带控制台的，如果直接使用<code>rabbitmq</code>拉取的没有控制台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 5672:5672 -p 15672:15672 -v --hostname my-rabbitmq -e RABBITMQ_DEFAULT_VHOST&#x3D;my-vhost -e RABBITMQ_DEFAULT_USER&#x3D;admin -e  RABBITMQ_DEFAULT_PASS&#x3D;admin --name rabbitmq-server --restart&#x3D;always rabbitmq:3.7.7-management</span><br></pre></td></tr></table></figure><ul><li><code>-p 5672:5672 -p 15672:15672</code>：1572是<code>rabbitmq</code>服务端口，15672是<code>rabbitmq</code>控制台端口</li><li>-<code>-hostname my-rabbitmq</code> ：主机名</li><li><code>-e RABBITMQ_DEFAULT_VHOST=my-vhost</code>：指定虚拟机</li><li><code>-e RABBITMQ_DEFAULT_USER=admin</code> ：指定用户名</li><li><code>-e RABBITMQ_DEFAULT_PASS=admin：</code>：指定密码</li><li><code>--restart=always</code>：随容器启动</li></ul><h2 id="Docker启动nacos"><a href="#Docker启动nacos" class="headerlink" title="Docker启动nacos"></a>Docker启动nacos</h2><p>通过mysql创建 <a href="https://github.com/alibaba/nacos/blob/develop/config/src/main/resources/META-INF/nacos-db.sql">nacos-db.sql</a> 中的表，由于nacos和mysql都在docker中，配置<code>MYSQL_SERVICE_HOST</code>时，使用docker中mysql服务的ip地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd  -e PREFER_HOST_MODE&#x3D;hostname -v &#x2F;C&#x2F;nacos&#x2F;logs:&#x2F;home&#x2F;nacos&#x2F;logs  -e MODE&#x3D;standalone  -e SPRING_DATASOURCE_PLATFORM&#x3D;mysql  -e MYSQL_SERVICE_HOST&#x3D;172.17.0.3 -e MYSQL_SERVICE_PORT&#x3D;3306 -e MYSQL_SERVICE_USER&#x3D;root -e MYSQL_SERVICE_PASSWORD&#x3D;123456 -e MYSQL_SERVICE_DB_NAME&#x3D;nacos-config -e MYSQL_SLAVE_SERVICE_HOST&#x3D;172.17.0.3 -p 8848:8848  --name nacos-server --restart&#x3D;always  nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure><ul><li>-e PREFER_HOST_MODE=hostname ：表示支持hostname，默认为ip模式</li><li>-e MODE=standalone：表示单机模式</li><li>-v /C/nacos/logs:/home/nacos/logs：将日志映射出来</li><li>-e MYSQL_SERVICE_*：MYSQL_SERVICE_开头的为mysql的配置信息</li></ul><h2 id="Docker启动elasticsearch"><a href="#Docker启动elasticsearch" class="headerlink" title="Docker启动elasticsearch"></a>Docker启动elasticsearch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --restart&#x3D;always --name elasticsearch-server -v  &#x2F;C&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml -v &#x2F;C&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data -v  &#x2F;C&#x2F;elasticsearch&#x2F;logs:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;logs -p 9200:9200 -p 9300:9300 -e &quot;discovery.type&#x3D;single-node&quot; elasticsearch</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下配置说明都是基于windows系统&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker常用命令&quot;&gt;&lt;a href=&quot;#Docker常用命令&quot; class=&quot;headerlink&quot; title=&quot;Docker常用命令&quot;&gt;&lt;/a&gt;Docker常用命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;docker search 镜像名&lt;/code&gt; ：搜索一个指定的镜像。例如&lt;code&gt;docker search redis&lt;/code&gt;,可能会搜索出多个，但是一般选择第一个，也就是starts数最高的一个。
    
    </summary>
    
    
      <category term="工具" scheme="https://yingu.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="docker" scheme="https://yingu.site/categories/%E5%B7%A5%E5%85%B7/docker/"/>
    
    
      <category term="docker" scheme="https://yingu.site/tags/docker/"/>
    
      <category term="工具" scheme="https://yingu.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【Springloc流程解析】--1. Springloc的基本组件和流程</title>
    <link href="https://yingu.site/2020/04/28/Spring-loc-1/"/>
    <id>https://yingu.site/2020/04/28/Spring-loc-1/</id>
    <published>2020-04-28T11:22:34.000Z</published>
    <updated>2021-07-18T12:31:14.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        本章开始解析SpringLoc的执行流程，我认为要搞懂spring的源码，最好的办法不是立即针对核心功能进行解析，而是我们首先要了解SpringLoc执行的步骤，纵观全局，最后再对单独的步骤逐个击破，最终串起SpringLoc的整个执行逻辑。<a id="more"></a></p><p>​        解析代码之前我们先来回顾一下，我们平时了解的SpringLoc步骤。我们知道SpringLoc是一个<strong>容器</strong>，根据我们定义bean信息的xml文件(此处不讨论注解)，最终来解析成一个个的<strong>bean对象</strong>存放到容器中，在我们需要使用到某个bean时，springloc会自动帮我们注入，当然我们也可以通过一个ApplicationContext的getBean(“myBean”)来获取一个我们需要的bean对象，那么从xml的读取转为bean，到最后我们成为一个可供我们使用的bean对象，这其中经历了哪些步骤呢？就让我们一起来看看吧！</p><h2 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p><code>org.springframework.core.io.Resource</code>，资源访问定位。由于springloc支持以不同的方式、从不同的位置进行资源的获取，因此通过<code>Resource</code>类将资源抽象，而它的每一个实现类都代表了一种资源的访问策略，如<code>ClassPathResource</code>、<code>FileSystemResource</code>、<code>ServletContextResource</code>它们分别从不同的位置获取资源。</p><ul><li><p><code>FileSystemResource</code>：以文件系统绝对路径的方式进行访问</p></li><li><p><code>ClassPathResource</code>：以类路径的方式进行访问</p></li><li><p><code>ServletContextResource</code>：以相对于Web应用根目录的方式进行访问。</p></li></ul><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p><code>org.springframework.core.io.ResourceLoader</code>，有了资源，我们就需要加载资源。<code>ResourceLoader</code>的作用就是用来进行资源的加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认在classpath路径下，寻找文件加载</span></span><br><span class="line">    String CLASSPATH_URL_PREFIX = <span class="string">"classpath:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取资源，返回一个Resource对象</span></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的类加载器</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的定位路径，选择不同的策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">    Iterator var2 = <span class="keyword">this</span>.getProtocolResolvers().iterator();</span><br><span class="line"></span><br><span class="line">    Resource resource;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!var2.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getResourceByPath(location);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (location.startsWith(<span class="string">"classpath:"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(<span class="string">"classpath:"</span>.length()), <span class="keyword">this</span>.getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">                <span class="keyword">return</span> (Resource)(ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException var5) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getResourceByPath(location);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProtocolResolver protocolResolver = (ProtocolResolver)var2.next();</span><br><span class="line">        resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span>(resource == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResourceLoader</code>中只定义两个方法，<code>getResource()</code>根据给定的资源文件地址返回一个对应的<code>Resource</code>，<code>getClassLoader()</code>获取类加载器。</p><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p><code>org.springframework.beans.factory.config.BeanDefinition</code>，它并不是我们使用的bean，而是用于描述bean的信息，里面存放着的是bean的元数据。相当于<code>BeanDefinition</code>是bean的一个模板，我们通过模板来创建的bean具有<code>BeanDefinition</code>的基础信息，当然我们也可以对将要创建的bean进行其他的扩展，自己定制不同特性的bean对象。</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><p><code>org.springframework.beans.factory.support.BeanDefinitionReader</code>，用于读取配置的资源文件，并将其转化成容器中的<code>BeanDefinition</code>。<code>BeanDefinitionReader</code>是一个接口，类似于上面的<code>Resource</code>抽象资源，实现<code>BeanDefinitionReader</code>的子类，代表着不同的读取策略。而我们本系列的解析主要是针对<code>XmlBeanDefinitionReader</code>来进行讲解的。</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><code>org.springframework.beans.factory.BeanFactory</code>，顾名思义bean工厂，用来存储<code>BeanDefinition</code>信息，以及创建并存储bean对象。前面说过通过<code>BeanDefinition</code>当做模板来进行bean的创建，当我们需要创建大量的bean对象时，使用工厂的方式来进行创建也就顺理成章了。通过实现<code>BeanFactory</code>我们就可以通过<code>BeanDefinition</code>创建不同的特性的bean对象了。<code>BeanFactory</code>在<code>springloc</code>中极为重要，实现了<code>BeanFactory</code>的接口也是非常之多，我们也不在这里一一列举了。</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/BeanFactory.png" alt=""></p><p><code>DefaultListableBeanFactory</code>几乎继承了所有其他<code>BeanFactory</code>父接口，是一个集大成者的<code>BeanFactory</code>，涵盖了<code>BeanFactory</code>中的大部分功能，是功能最全的一个<code>BeanFactory</code>，同时继承自<code>AliasRegistry</code>具有别名注册的功能。</p><ul><li><code>AliasRegistry</code>：提供别名注册的接口。</li><li><code>BeanDefinitionRegistry</code>：提供对<code>BeanDefinition</code>注册的接口。</li><li><code>SimpleAliasRegistry</code>：实现了<code>AliasRegistry</code>，使用map作为alias的缓存。</li><li><code>SingletonBeanRegistry</code>: 提供单例bean注册的接口。</li><li><code>DefaultSingletonBeanRegistry</code>：继承自<code>SimpleAliasRegistry</code>、实现了<code>SingletonBeanRegistry</code>接口，因此它同时具有注册别名和单例bean的功能。</li><li><code>HierarchicalBeanFactory</code>：实现了bean工厂的分层，可以将各个<code>BeanFactory</code>设置为父子关系，同时提供了父容器的访问功能。</li><li><code>ListableBeanFactory</code>：提供了批量获取bean实例的方法。</li><li><code>FactoryBeanRegistrySupport</code>：继承自<code>DefaultSingletonBeanRegistry</code>，增加了对<code>FactoryBean</code>的处理功能。</li><li><code>ConfigurableBeanFactory</code>：提供了配置各种bean的方法。</li><li><code>AbstractBeanFactory</code>：综合了<code>FactoryBeanRegistrySupport</code>与<code>ConfigurableBeanFactory</code>的功能。</li><li><code>AutowireCapableBeanFactory</code>：继承自<code>BeanFactory</code>，提供创建bean、自动注入、初始化以及应用bean的后置处理器。</li><li><code>AbstractAutowireCapableBeanFactory</code>：综合了<code>AbstractBeanFactory</code>与<code>AutowireCapableBeanFactory</code>的功能。</li><li><code>ConfigurableListableBeanFactory</code>：<code>BeanFactory</code>的配置清单，指定忽略类型以及接口。</li><li><code>DefaultListableBeanFactory</code>综合上面的所有功能，主要是对bean注册后的处理。</li></ul><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><code>org.springframework.context.ApplicationContext</code>，Spring的应用上下文，<code>ApplicationContext</code>继承自<code>BeanFactory</code>，同时还继承了其他丰富的组件，基本上<code>ApplicationContext</code>将Springloc中的所有组件功能都组合到一起了。 </p><p>通过实现<code>ApplicationContext</code>提供不同的上下文环境。</p><ul><li><code>ClassPathXmlApplicationContext</code>：从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式，也就是我们本系列需要讲解的重点。</li><li><code>AnnotationConfigApplicationContext</code>：从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。</li><li><code>FileSystemXmlApplicationContext</code>：从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。</li><li><code>XmlWebApplicationContext</code>： 从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。后面我们讲解Springmvc的时候会讲到。</li><li><code>AnnotationConfigWebApplicationContext</code>：专门为web应用准备的，适用于注解方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"testA.xml"</span>);</span><br><span class="line">    TestA testA = (TestA)context.getBean(<span class="string">"testA"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过创建一个<code>ClassPathXmlApplicationContext</code>通过传入配置bean信息的xml文件名称，最终返回一个<code>ApplicationContext</code>对象。我们通过<code>ApplicationContext</code>对象的<code>getBean()</code>方法，就可以获取到我们想要的对象，而不用我们自己通过new方法去实例化一个对象，那么spring是怎么做的，这其中又经历了哪些方法，就让我们从这段代码开始。</p><p>​        我们先来看看<code>ClassPathXmlApplicationContext</code>的结构图。</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/ClassPathXmlApplicationContext.png" alt=""><code>ClassPathXmlApplicationContext</code>到顶层<code>BeanFactory</code>、<code>ResourceLoader</code>继承关系较为复杂，让我们从最顶层的<code>BeanFactory</code>与<code>ResourceLoader</code>来介绍每个类的特点与作用。</p><h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><p>从我们的 <code>new ClassPathXmlApplicationContext(&quot;testA.xml&quot;)</code>方法开始说起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将传入的ApplicationContext对象设置为当前的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们上面调用的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> String[]&#123;configLocation&#125;, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入多个XML配置的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String... configLocations)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(configLocations, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入多个XML配置，并指定父类ApplicationContext</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, @Nullable ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(configLocations, <span class="keyword">true</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入多个XML配置，选择是否需要刷新容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(configLocations, refresh, (ApplicationContext)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的构造方法最终都要调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类构造方法，最终在AbstractApplicationContext构造方法中完成构建</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="comment">//根据提供的路径，解析成配置文件数组</span></span><br><span class="line">        <span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">//刷新容器</span></span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//省略一些方法.....</span></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassPathXmlApplicationContext</code>中的<code>super(parent)</code>，一直到<code>AbstractApplicationContext</code>中完成构造工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line">        <span class="comment">//生成id</span></span><br><span class="line">        <span class="keyword">this</span>.id = ObjectUtils.identityToString(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//生成展示名</span></span><br><span class="line">        <span class="keyword">this</span>.displayName = ObjectUtils.identityToString(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//初始化beanFactory的后置处理集合</span></span><br><span class="line">        <span class="keyword">this</span>.beanFactoryPostProcessors = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">this</span>.active = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">        <span class="keyword">this</span>.closed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">        <span class="keyword">this</span>.startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//初始化监听器</span></span><br><span class="line">        <span class="keyword">this</span>.applicationListeners = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        <span class="comment">//初始化资源解析器</span></span><br><span class="line">        <span class="keyword">this</span>.resourcePatternResolver = <span class="keyword">this</span>.getResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>setConfigLocations</code>方法中做了什么。</p><h3 id="setConfigLocations方法"><a href="#setConfigLocations方法" class="headerlink" title="setConfigLocations方法"></a>setConfigLocations方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractRefreshableConfigApplicationContext #setConfigLocations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(@Nullable String... locations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//通过resolvePath解析路径并返回</span></span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = <span class="keyword">this</span>.resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractRefreshableConfigApplicationContext #setConfigLocations</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取一个ConfigurableEnvironment对象，用来解析占位符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果environment不存在，那么创建一个</span></span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">this</span>.createEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardEnvironment</span> <span class="keyword">extends</span> <span class="title">AbstractEnvironment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">"systemEnvironment"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">"systemProperties"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StandardEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">        propertySources.addLast(<span class="keyword">new</span> PropertiesPropertySource(<span class="string">"systemProperties"</span>, <span class="keyword">this</span>.getSystemProperties()));</span><br><span class="line">        propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource(<span class="string">"systemEnvironment"</span>, <span class="keyword">this</span>.getSystemEnvironment()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        本章开始解析SpringLoc的执行流程，我认为要搞懂spring的源码，最好的办法不是立即针对核心功能进行解析，而是我们首先要了解SpringLoc执行的步骤，纵观全局，最后再对单独的步骤逐个击破，最终串起SpringLoc的整个执行逻辑。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="spring" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/spring/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="spring" scheme="https://yingu.site/tags/spring/"/>
    
      <category term="loc" scheme="https://yingu.site/tags/loc/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解java虚拟机】-- 虚拟机类加载机制</title>
    <link href="https://yingu.site/2020/04/22/JVM-ClassLoading/"/>
    <id>https://yingu.site/2020/04/22/JVM-ClassLoading/</id>
    <published>2020-04-22T06:41:21.000Z</published>
    <updated>2021-07-18T12:31:14.985Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列内容，大量引用自《<a href="https://book.douban.com/subject/6522893/">深入理解java虚拟机</a>》。</p></blockquote><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>​        类在虚拟机中整个声明周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。<a id="more"></a></p><p>​        <img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt=""></p><p>​        加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的(按照顺序按部就班的开始，是不是按照顺序完成就不一定了)，而解析阶段则不一定：它在某种情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表整个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口。</li></ol><p>“通过一个类的全限定名来获取定义此类的二进制字节流”，并没有指明二进制字节流要从要给Class文件中获取，准确的说是根本没有指明要从哪里获取，怎样获取。</p><ul><li>从ZIP包获取，我们常见的JAR,EAR,WAR</li><li>从网络获取，这种场景最典型的就是Applet</li><li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了proxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li><li>其他文件生成，典型的就是由JSP文件生成对应的Class类。</li><li>从数据库读取，比较少见。有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发</li></ul><p>相对于类加载过程的其他阶段，一个非数组类的加载阶段是开发人员可控性最强的，可以选择使用系统提供的引导类加载器来完成，也可以由用户自定义的类完成(例如重写一个类加载器的loadClass方法)。</p><p>​        而数组类本身不通过类加载器创建，它是由虚拟机直接创建的。但是数组类与类加载器仍然存在关系，因为数组类的元素类型最终是要由类加载器去创建，一个数组类创建的过程遵循以下规则：</p><ul><li><p>如果数组的组件类型是引用类型，那就递归加载过程去加载这个组件类型。</p></li><li><p>如果不是组件类型(例如int[])，java虚拟机会将把数组标记为与与引导类加载器关联。</p></li><li><p>数组类的可见性与其他的组件类型的可见性一直，如果组件类型不是引用类型，那数组类的可见性将默认为public。</p></li></ul><p>​        加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区。然后再内存中实例化一个Java.lang.Class类对象。这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​        验证时连接阶段的第一步，确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>​        验证阶段大致上会完成下面4个阶段的校验动作：</p><ol><li><p><strong>文件格式验证</strong></p><ol><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前虚拟机处理范围之内。</li><li>常量池中的常量是否有不被支持的常量类型(检查常量tag标志)。</li><li>CONSTANT_Utf8_info类型的常量中是否有不符合UTF8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或者附加的其他信息</li><li>……</li></ol></li><li><p><strong>元数据验证</strong></p><ol><li>这个类是否有父类(除了java.lang.Object之外，所有类都应该有父类)</li><li>这个类是否继承了不允许被继承的类(被final修饰的类)</li><li>如果不是抽象类，是否实现了其父类或接口中要求实现的所有方法</li><li>类中的字段、方式是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规范的方法重载)</li></ol></li><li><p><strong>字节码验证</strong></p><pre><code>第三阶段时整个验证过程中最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是否合法、符合逻辑。保证被校验类的方法在运行时不会出现危害虚拟机安全的事件</code></pre><ol><li>保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作。例如不会出现：在操作数栈方值了一个int类的的数据，使用时却按照long类型来加入到本地变量表中。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的，例如把父类对象赋值给子类数据类型，甚至把对象赋值给与他毫无继承关系、完全不相干的一个数据类型，则是危险且不合法的。</li></ol></li><li><p><strong>符号引用验证</strong></p><p>​      最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，整个转化动作将在连接的第三个阶段–解析阶段中发生。符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验，通常需要校验下列内容：</p><ol><li><p>符号引用中通过字符串描述的全限定名是否能找到对应的类。</p></li><li><p>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</p></li><li><p>符号引用中的类、字段、方法的访问性是否可以被当前类访问</p></li></ol><p>​        如果无法通过符号引用验证，那么会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p><p>​        对于虚拟机类加载机制来说，验证是一个非常重要的的、但不一定必须要的阶段(对运行期无影响)。如果所运行的全部代码(包括自己编写的代码)都已经被反复使用和验证过，那么可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。</p></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>​        准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。注意，类变量(被static修饰的变量)不包括实例变量，实例变量会在对象实例化时随对象一起分配在Java堆中。其次，这里说的初始值“通常情况”时数据类型的零值，假设一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量value在准备阶段过后的初始值为0为不是123，把value赋值为123的动作将在初始化阶段才会执行。有一个例外，如果字段属性表中存在ConstantValue属性，那么在准备阶段就会初始为ConstantValue属性指定的值,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>​        解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用前面讲Class文件格式出现过多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那么解析阶段所说的直接引用与符号引用的关系又有什么关联呢？</p><ul><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现地内存布局不管，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受地符号引用必须是一致的，因为符号引用的字面量形式明确定义在java虚拟机规范的Class文件格式中。</li><li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能直接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机实力上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​        类初始化阶段是类加载过程的最后一步。到了初始化，才真正开始执行类中定义的Java程序代码</p><p>​        java虚拟机规范并没有强制约束类什么时候加载，但是对于初始化阶段，虚拟机严格规定了5种情况必须对类进行“初始化”(加载、验证、准备自然需要在此之前开始)：</p><ol><li>需要new、getstatic、putstatic或invokestatoc这4条字节码指令时，如果类没有进行过初始化。则需要先触发其初始化。使用整个4条指令常见的Java代码场景时：使用new实例化对象、读取或者设置一个类的静态字段(不包括被final修饰的，因为编译的时候已经把结果放入到了常量池中)，以及调用一个类的静态方法的时候。</li><li>使用Java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类，如果发现父类还没有进行过初始化，则需要先触发父类的初始化。</li><li>虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类(包括main()方法的那个类)。</li><li>当使用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_pubStatic、REF_invokeStatic的方法句柄、并且这个方法句柄所对应的类没有进行过初始化、则需要先触发其初始化。</li></ol><p>​        对于这5中会触发类进行初始化的场景、虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方法都不会触发初始化，称为被动引用。例如：通过子类引用父类的静态字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">'father init'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">     System.out.print(<span class="string">'children init'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    System.out.print(Children.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        此时只会输出“father init”，而不会输出“children init”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。致于是否要触发子类的加载和验证，虚拟机终规范中没有明确规定。对于Hot Spot虚拟机来说，可通过-XX:+TraceClassLoading参数观察到此操作会导知子类的加载。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>​        类加载虽然只用于实现类的加载动作，但是它的作用远远不限于此。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗点就是说，两个类是否相等，不仅需要来源同一个Class文件，还需要被同一个虚拟机架加载。</p><p>​        这里的”相等”，包括代表类的Clas对象的equals()方法，isAssignableForm()方法、isInstance()方法的返回结果，也包括使用instanceof判定对象所属关系等情况。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从java虚拟机的角度来讲，只存在两种不同加载器：</p><ol><li>启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分</li><li>所有其他类加载器，都有java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader。</li></ol><p>从java开发人员角度来看，类加载器可以分的更细致，绝大部分java程序都会使用以下三种系统提供的类加载器。</p><ol><li><p>启动类加载器(Bootstrap ClassLoader)，就是上面介绍的，主要负责讲存在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</p></li><li><p>扩展类加载器(Extension ClassLoader): 由sun,misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib、ext目录中的，或者被java。ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p></li><li><p>引用程序类加载器(Application ClassLoader):这个类加载由sun,misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>我们应用程序都是由这三种类加载机相互配合加载的，如果有必要还可以加入自己定义的类加载器。它们之间的关系如图：</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt=""></p></li></ol><p>​        图中展示的类加载器之间的这种层级关系，称之为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外、其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的关系一般不会以继承的关系实现，而是都使用组合关系来复用父加载器的代码。</p><p>​        <strong>双亲委派模型的工作过程是：如果一个类收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层级的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成这个加载请求时(它的搜索范围类没有找到所需的类)，子加载器才会尝试自己去加载。</strong></p><p>​        双亲委派模型好处就是Java类随着它的类加载器一起具备了一种带有优先级的层级关系。例如类Java.lang.Object,存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。如果用户没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为Java.lang.Object的类(实际上虚拟机不允许用户自己加载以“java.lang”开头的类，会抛出异常)，并存放在程序的ClassPath中，那么系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，引用程序也将会变得一片混乱。</p><p>​        双亲委派模型实现非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法中。大致流程：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果父类不为null，那么使用父类加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果父类为null，那么使用启动类加载器加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果父类没找到，那么由当前加载器加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//通过findClass方法，搜索class文件</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>​        双亲委派并不是强制性的约束模型，而是java设计者推荐给开发者的类加载器实现方式。如果某些情况我们要突破这种模型的限制该如何做：其实java中也出现过双亲模型被破坏的情况。</p><ol><li><p>上面loadClass方法的代码，就是一个被破坏的入口，当用户去继承java.lang.ClassLoader并重写loadClass方法，那么双亲委派模型就会被打破，想符合双亲委派模型也很简单，只需要重写findclass方法，最终通过defineClass方法将找到的类加入到虚拟机即可。</p></li><li><p>还有一种情况是由这个模型自身缺陷所导致的，双亲委派模型中，我们加载类都是委托给父类加载，最终经过启动类加载器，可能访问到启动类加载器中加载的java.lang.Object类，如果此时Object需要调回用户代码的时候呢。</p><pre><code>一个典型的例子便是JNDI，JNDI现在已经时java标准服务，他的代码由启动类加载器去加载，但是JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在引用程序的ClassPath下的JDNI接口提供者(SPI，Service Provider Interface)的代码，但是启动类加载器不可能”认识“这些代码。为了解决这个问题，java设计团队引入了一个不太优雅的设计：线程上下文加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未被设置，它将从父线程中继承一个，如果应用在全局范围内都没有设置过，那这个类加载器默认就是应用程序类加载器。</code></pre><p>​        有了线程上下文加载器，JDNI服务就可以使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类记载器亲求子类加载器去完成类加载的动作，通过逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。</p></li><li><p>第三次被“破坏”是由于用户对程序动态性的追求而导知的，这里说的“动态性”指的是：代码热替换(HotSwap)、模块部署(Hot Deployment)等。OSGI中实现模块化热部署的关键是它自定义的类加载器机制的实现。每个程序模块(OSGI中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就要把Bundle连同类加载器一起替换掉一实现代码的热替换。</p><pre><code>在OSGI环境下，类加载不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGI将按照下面的顺序进行类搜索:</code></pre><ol><li><p>将以java.*开头的类委派给父类加载器加载。</p></li><li><p>否则，将委派列表名单内的类委派给父类加载器加载。</p></li><li><p>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</p></li><li><p>否则，查找当前Bundle的ClassPath,使用自己的类加载器加载。</p></li><li><p>否则，查找类是否在自己的Fragment Bundel中，如果在，则委派给Fragment Bundel的类加载器加载</p></li><li><p>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载</p></li><li><p>否则，类查找失败。</p><p>上面的查找顺序只有开头两点符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列内容，大量引用自《&lt;a href=&quot;https://book.douban.com/subject/6522893/&quot;&gt;深入理解java虚拟机&lt;/a&gt;》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;类加载时机&quot;&gt;&lt;a href=&quot;#类加载时机&quot; class=&quot;headerlink&quot; title=&quot;类加载时机&quot;&gt;&lt;/a&gt;类加载时机&lt;/h2&gt;&lt;p&gt;​        类在虚拟机中整个声明周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。
    
    </summary>
    
    
      <category term="jvm" scheme="https://yingu.site/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://yingu.site/tags/jvm/"/>
    
      <category term="class" scheme="https://yingu.site/tags/class/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解java虚拟机】-- 垃圾收集器与内存分配策略</title>
    <link href="https://yingu.site/2020/04/05/jvm-GarbageCollection/"/>
    <id>https://yingu.site/2020/04/05/jvm-GarbageCollection/</id>
    <published>2020-04-05T03:33:07.000Z</published>
    <updated>2021-07-18T12:31:14.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列内容，大量引用自《<a href="https://book.douban.com/subject/6522893/">深入理解java虚拟机</a>》，说是照抄一遍也不为过。不过作者自己也加入了一些图文用来帮助理解。</p></blockquote><h2 id="对象是否存活"><a href="#对象是否存活" class="headerlink" title="对象是否存活"></a>对象是否存活</h2><p>​        在堆中存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，那些已经“死去”(即不能再被任何途径使用的对象)。<a id="more"></a></p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>​        给对象中添加一个引用计数器，每当有一个地方引用它时，计时器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象，就是不可能再被使用的。这种方式虽然实现简单、效率也很高，但是主流的java虚拟机里面没有选用引用计数法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object q1 = <span class="keyword">new</span> GcObject(); <span class="comment">//实例1，引用数+1</span></span><br><span class="line">Object q2 = <span class="keyword">new</span> GcObject(); <span class="comment">//实例2，引用数+1</span></span><br><span class="line"></span><br><span class="line">q1.instance = q2; <span class="comment">//将实例1中的instance熟悉指向实例2，实例2，引用数+1</span></span><br><span class="line">q2.instance = q1; <span class="comment">//将实例2中的instance熟悉指向实例1，实例1，引用数+1</span></span><br><span class="line"></span><br><span class="line">q1 = <span class="keyword">null</span>; <span class="comment">//实例1，引用数-1</span></span><br><span class="line">q2 = <span class="keyword">null</span>; <span class="comment">//实例2，引用数-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//垃圾回收后，实例1，实例2还存在堆中，不会被回收</span></span><br><span class="line"><span class="comment">//System.gc();</span></span><br></pre></td></tr></table></figure><p>​        上面代表就描述了，引用计数器在实际使用中会出现的一个循环引用的问题。对象没有被其他地方引用，但是计数器值不为0，此时实例1、2无法被回收，也就是我们常说的内存泄漏。</p><p>​        之前看到过一个问题，为什么jvm知道object的细节，但是在实现q1=null这条语句之前,不先将q1内部实例全部引用设置为null(也就是将q1.instance也置为null)呢？</p><p>问题是，虚拟机不能肯定q1.instance指向的也是垃圾，就不能随便修改它的内容。当遇到复杂的庞大的循环链结构时，我们又如何确定指向的对象会成为垃圾呢，就算是一个个寻找是否有其他对象引用，最终还是会存在循环引用问题。因此如果采用计数器法，那么必然要手动将instance置为null。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​        在主流的商用程序语言的主流实现中，都是称通过可达性分析来判断对象是否存活的。这个算法的基本思路就是通过一系列的成为“GC Roots”的对象做为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。下图中，对象5、6、7虽然互相有关联，但是他们到GC Root是不可达的，所以他们江湖判定为是可回收的对象。</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.png" alt=""></p><p>在java语言中，可做为GC Root的对象包括下面几种</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li><li>元空间中类静态属性引用的对象</li><li>元空间中常量引用的对象</li><li>本地方法中JNI(即一般说的Native方法)引用的对象</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>​        无论是通过引用计数法判断对象的引用数量，还是通过可达性分析法判断对象的引用链是否可达，判断对象是否存货都与“引用“有关。JDK 1.2以前，java中的引用定义很传统：如果reference类型的数据中存储的数据代表的是另一块内存的起始地址，就成这块内存代表着一个引用。一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些”食之无味，弃之可惜“的对象就显得无能为力。</p><p>​    因此在JDK 1.2以后，Java对引用的概念进行了扩充，将应用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种、这4中引用强度依次逐渐减弱。</p><ul><li>强引用：就是指在程序代码中普普遍存在的，类似”Object obj = new Object()“这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用：用来描述一些还有用，但并非必需的对象。JVM在将要发生内存溢出前，会把这些对象回收。通过SoftReference类来实现软引用。</li><li>弱引用：也是用来描述非必需对象的。当垃圾收集器工作时，无论当前内存是否足够，弱引用对象都会被回收。通过WeakReference类来实现弱引用时，可以指定一个ReferenceQueue，如果弱引用所引用的对象被回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li><li>虚引用：是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响；也无法通过虚引用来取的一个对象实例。一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收时收到一个系统通知。通过PhantomReference类来实现虚引用时必须指定一个ReferenceQueue队列，目标对象被回收前，它的引用会被放入该队列。目前在NIO中，就运用了虚引用管理堆外内存，通过虚引用指向堆外内存的地址，如果被回收，那么去堆外内存中查看对象是否存在，如果存在，那么将其回收。</li></ul><h3 id="对象死亡判定"><a href="#对象死亡判定" class="headerlink" title="对象死亡判定"></a>对象死亡判定</h3><p>​        即使在可达性分析算法中不可达的对象，也并非是“非死不可的”，这个时候它们暂时处于”缓刑“阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ol><li><p>通过可达性分析法判断对象的引用链不可达时，进行第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法或者该方法被虚拟机调用过，虚拟机将这两种情况视为“没有必要去执行”。</p><p>如果该对象被判定为有必要执行finalize()方法，那么这个对象会被放置到一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去执行它。这里所谓的”执行“就是去触发该方法，但并不会承诺等待它执行结束，这样做的原因是，如果对象在finalize()方法中执行缓慢，或者发生死循环，将会导致整个队列中的对象永久处于等待，甚至导知整个内存回收系统崩溃。</p></li><li><p>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中拯救自己——只要重新与引用链上的一个对象重新建立关联即可，譬如将自己（this关键字）赋值给某个类变量或者成员变量，那么在第二次标记的时候就会被移除“即将回收”的集合；如果对象这时候还没有逃脱，那么就会被真的回收了。</p></li></ol><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1.png" alt=""></p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>​        很多人认为方法区是没有垃圾收集的，java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的”性价比“一般比较低；在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p><p>​        永久代的垃圾收集主要回收两部分内容，废弃常量和无用的类。判断一个常量是否是”废弃常量“比较简单，而要判定一个类是否是”无用的类“的条件则相对苛刻许多。类需要同时满足一下三种条件才算是“无用的类”。</p><ol><li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对于的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是”可以“，而不是和对象一样不使用了就必然会回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>​        最基础的收集算法(Mark-Sweep)，顾名思义，先标记再清除。</p><p>​        首先标记出所有需要回收的对象，再标记完成后统一回收所有被标记的对象。之所以说是最基础的收集算法，是因为后续的收集算法都是基于这种思路改进的。</p><p>优点：简单</p><p>缺点：</p><ol><li>效率不高，标记和清除两个过程效率都不高</li><li>标记清除后会产生大量不连续的内存碎片，空间碎片较多可能会导知以后再程序运行过程中需要分配大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><p>适用于老年代，一般和标记整理算法搭配使用，老年区可能经过多次GC后，才会采用标记整理的算法压缩内存</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>​        为了解决效率问题，复制收集算法出现了，它将可用内存按照容量划分为大小相等的两块，每次只需使用其中的一块。当这一块内存用完了，就将存活着的对象复制到另外一块上面。然后把已经使用过的内存空间一次清理掉。这样使的每次都是对整个半区进行内存回收，也不用考虑内存碎片的问题。只要移动指针，按顺序分配内存即可，实现简单，运行高效，不足之处在于内存的使用率太低。</p><p>​        现在商业虚拟机都采用这种收集算法来回收新生代，有公司研究表明，新生代中的对象98&amp;都是”朝生夕死“，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新生代的90%，只有10%被浪费。当然，98%的对象可回收只是一般场景下的数据，我们没法保证每次回收的都只有不多于10%的对象存货，当Survivor空间不够是，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。</p><p>​    分配担保：如果另一块Survivor空间没有足够的空间存放上一次新生代中收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><p>优点：简单，高效</p><p>缺点：内存使用率低</p><p>适用于新生代，针对频繁的回收，通过空间换时间方法提高回收的效率，同时保持内存的使用率在一个可接受的范围。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>​        复制收集算法在对象存活率较高时就要较多的复制操作，效率会较低。更关键的是如果不想浪费50%的空间，就需要额外的空间进行担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>​        根据老年的特性，有人提出来另外一种“标记-整理”算法，标记过程与“标记-清除”算法一样，但后续的步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</p><p>优点：简单，节省空间</p><p>缺点：比标记-清除算法还多了整理这一步，而整理的效率也很低</p><p>适用于老年代，不会频繁的回收，同时具有压缩功能，节省老年代内存，减小触发Full GC收集的次数</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>​        根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据个年代的特点采用最适合的收集算法。新生代中每次垃圾收集时都发现有大批对象死去，只有少量存活，适合复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为存活率较高、没有额外的空间进行担保，就必须使用“垃圾-清除”或者“标记-整理”算法来进行回收。</p><h2 id="hptspot的算法实现"><a href="#hptspot的算法实现" class="headerlink" title="hptspot的算法实现"></a>hptspot的算法实现</h2><p>​        前面介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上是实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>​        前面可达性分析法中说过通过GC Roots节点找引用链，通过是否可达判断对象的存活。而GC Root节点主要在全局的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)，如何快速高效找出可作为GC Root的节点，便成为了一个问题。</p><p>​        可达性分析必须在一个能确保一致性的快照中进行，也就是说在执行可达性分析时，不能出现分析过程中对象引用关系还在不断发生变化的情况，否则分析结果的准确性无法得到保证。这点是导致GC进行时必须停顿所有java执行线程的其中一个重要原因，即使是在号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><p>​        由于目前主流的java虚拟机使用的都是准确性GC，所以当前执行系统停顿下来时，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放者对象的引用,在HotSpot的实现中,是使用一组称为OopMap的数据结构来达到这个目的得,在类加载完成的时候,HotSpot就把对象内什么偏移量上是什么类型的数据计算出来,在JIT编译过程中,也会在特点的位置记录下来栈和寄存器中哪些位置是引用,这样GC在扫描时就可以直接得知这些信息了。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>​        枚举根节点通过OopMap中记录的数据，可以快速准确的完成GC Roots枚举，但是又会导致引用关系变化，或者说OopMap内容变化的指令非常多，如果每一条都生成对应的OopMap，将会需要大量的额外空间，这样GC的空间成本太高。因此在实际中，HotSpot也没有为每条指令都生成OopMap，只是在“特定的位置”记录这些信息，这些位置被称为安全点(Safepoint)，即程序执行时并非在所有地方都能停顿下来开始GC，只有到达安全点时才能在暂停。</p><p>​        安全点的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显的特征就是指令序列服用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>​        对于Safepoint，另一个需要考虑的问题就是如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来。有两种方案可供选择：抢先式中断和主动式中断，其中抢先式中断不需要线程的执行代码主动区配合，在GC发生时，首先把所有的线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，就让它“跑“到安全点上。不过现在几乎没有虚拟机采用抢先式中断来暂停线程而响应GC事件。</p><p>​        而主动中断的思想是当前GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标记，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地址。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>​        前面说了通过让所有线程集中”跑“到Safepoint，来进入GC，如果此时程序处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，去安全的地方挂起，这个时候就需要安全区域来(Safe Region)解决。</p><p>​        安全区域是指再一段代码片段中，引用关系不会发生变化。这个区域中任何地方GC都是安全的，可以把Safe Region看做是被扩展的Safepoint。</p><p>​        在线程执行到Safe Region中的代码时，首先表示自己已经进入了Safe Region，那样，当这段事件里JVM要发起GC时，就不用管标识自己的为Safe Region状态的线程了。在线程离开时，它要检查系统是否已经完成了根节点枚举(或者是整个GC过程)，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p><p>​        上面展示了不同分代的收集器，如果两个收集器之间存在连线，就说明他们可以搭配使用。虚拟机所处的区域，则表示它属于新生代收集器还是老年代收集器。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>​        采用复制算法的单线程收集器，进行垃圾收集器必须暂停其他所有工作线程，直到它收集结束(Stop The Word)。由于没有线程开销，可以在单CPU环境下获得最高的单线程收集效率。比较适合在运行在Client模式下的虚拟机。</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/Serial-Serial%20Old%20%E6%94%B6%E9%9B%86%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>​         Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、收集策略等都与Serial收集器完全一样。</p><p><strong>除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作。</strong></p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/ParNew-Serial%20Old%20%E6%94%B6%E9%9B%86%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>​        使用复制算法并行的多线程新生代收集器，看起来和ParNew一样。不过Parallel Scavenge收集器关注点与其他收集器不同，CMS更关注缩短用户收集时线程的停顿时间，而Parallel Scavenge目标是达到一个可控的吞吐量。</p><blockquote><p>所谓吞吐量就是CPU用于运行用户代码与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></blockquote><p>​        停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户提亚，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互任务。</p><p>​        Parallel Scavenge收集器提供了两个参数用于控制吞吐量，分别是最大垃圾收集停顿时间的-XX:MaxGCPauseMills参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p><p>​        MaxGCPauseMills参数设置一个值，收集器尽量保证内存回收花费的时间不超过设定值。但是GC停顿时间缩短是以牺牲吞吐量为代价的，比如：停顿时间设置较少，原先收集500M，现在只收集300M，但这也导致垃圾收集更频繁，原先10秒收集一次，每次停顿100毫秒，现在变为5秒收集一次，每次停顿70毫秒，停顿时间变少了，但是吞吐量也下来了。</p><p><strong>无法与CMS收集器配合工作</strong></p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/Parallel%20Scavenge-Parallel%20Old%20%E6%94%B6%E9%9B%86%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>​        Serial收集器的老年代版本，采用“标记-整理”算法，也是适用于Client模式下的虚拟机。不过同样适用于Server端，jdk1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，还有就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>​        看名字就知道，是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。是jdk1.6之后才提供的，抛弃了上面的Serial Old收集器，主要是Serial Old作为一个单线程收集器会拖后腿。无法将整体应用上获得吞吐量最大化的效果。还不如ParNew+CMS给力。</p><p>​        Parallel Scavenge+Parallel Old组合，本着“吞吐量优先”的原则，在注重吞吐量以及CPU资源敏感的场合下，都可以优先此组合。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>​        CMS(Concurrent Mark Sweep)收集器关注于获取最短回收停顿时间为目标的收集器，基于“标记-清除”算法实现，它的运作过程比前几款收集器更复杂，整个过程分为4个步骤</p><ul><li>初始标记(CMS initial mark): 标记GC Roots能直接关联的对象，速度很快，标记时需要Stop The World。</li><li>并发标记(CMS concurrent mark): 进行GC Roots Tracing的过程。耗时长，但是可以与用户线程一起工作。</li><li>重新标记：修正并发标记期间因用户程序继续运作而导知标记产生变动的那一部分对象的标记记录，也会Stop The World，并且停顿时间一般会比初始标记阶段稍长一些，但比并发标记时间短。</li><li>并发清楚：清除标记的垃圾，耗时长，可以与用户线程一起工作。</li></ul><p>CMS的缺点：</p><ol><li>CMS收集器对CPU资源非常敏感。在并发阶段，会因为占用一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>无法处理浮动垃圾，可能出现“Concurrent  Mode Failure”失败而导知另一次Full Gc的产生。由于在垃圾收集阶段用户线程还需要运行，那也就需要预留足够的内存空间给用户线程使用，因此CMS不能等到老年代满了才收集，需要预留一部分空间提供并发收集时的程序运作使用。JDK 1.6中，CMS收集器启动阈值为92%(可以通过-XX：CMSInitiatingOccupancyFraction来设置)，要是预留的内存无法满足需要，就会出现一次“Concurrent  Mode Failure”失败，这时虚拟机启动后备预案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，这样停顿就很高了。所以说-XX：CMSInitiatingOccupancyFraction设置的太高，容易导知大量“Concurrent  Mode Failure”失败，性能反而降低。</li><li>CMS基于‘“标记-清除”算法实现，收集结束时会有大量空间碎片。因此CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数(默认开启)，用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，但是副作用就是停顿时间会变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,用来设置执行了多少次不压缩的Full GC后，跟着来一次带压缩的(默认为0，标识每次Full GC时都要进行碎片整理)。</li></ol><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>​        G1收集器中还保留着新生代，老年代的概念，但是它们不再是物理隔离的了。在G1中，内存空间被分割成一个个的Region区，所谓新生代和老年代，都是由一个个Region组成的。同时G1也不需要跟别的收集器一起配合使用，自己就可以完成所有的收集工作，一款全能收集器。</p><p>​        与CMS的“标记-清除”算法不同，G1从整体上看时基于“标记-整理”算法实现的收集器，从局部(两个Region之间)上来看是基于“复制”算法实现的，无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片。</p><p>​        在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每一个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier展示中断写操作，检查Reference引用的对象是否处以不同的Region之中(在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象)，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中，当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>​        如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为一下几个步骤：</p><ul><li>初始标记：跟CMS收集器一样，标记GC Roots能直接关联的对象</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活对象，这步耗时久，但是可以与用户程序并发执行。</li><li>最终标记：由于并发标记阶段，用户线程仍然在运行，会对标记产生一些偏差，通过Remembered Set Log记录这些变化，此阶段会将这些变化合并到remembered set中，需要停顿线程，但是可以并行执行。</li><li>最终筛选：对各个Region回收价值和成本排序，根据用户期望的GC停顿时间来制定回收计划。</li></ul><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>​        对象的内存分配，往大的方向讲，就是在对上分配(但是也有可能经过JIT编译后被拆散为标量类型并间接地栈上分配)，对象主要分配在新生代地Eden区上，如果启动了本地线程分配缓冲，则按照线程优先在TLAB上分配。少数情况下也会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><h3 id="对象优先在eden分配"><a href="#对象优先在eden分配" class="headerlink" title="对象优先在eden分配"></a>对象优先在eden分配</h3><p>​            大多数情况下，对象在新生代Eden区中分配。当前Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>​        所谓大对象是指，需要大量连续内存空间的对象，最典型的就是很长的字符串以及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配，避免在Eden和两个Survivor区之间发生大量的内存复制。</p><h3 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h3><p>​            虚拟机给每个对象定义了一个对象年龄计数器。Eden中的对象经历过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1。每经历一次Minor GC，年龄数+1，年龄增加到一定程度(CMS默认6，其他默认15，可以通过-XX:MaxTenuringThreshold参数设置)，就会晋升到老年代中。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>​        虚拟机并不是永远要求对象年龄必须达到MaxTenuringThreshold设置的值才能晋升到老年代，如果Survivor中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或者等于该年龄的对象就可以直接进入老年代。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>​        发生Minor GC前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保安全。如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用联系空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC,尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p><p>​        JDK 1.6以后，规则变为只要老年代的连续空间大于新生代对象总大小或历次晋升的平均大小就行进行Minor GC，否则进行Full GC。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        <u>垃圾收集器与内存分配策略</u>到这里就结束了。后面会将JVM中所有的参数专门整合为一章，方便查找。:small_airplane:</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列内容，大量引用自《&lt;a href=&quot;https://book.douban.com/subject/6522893/&quot;&gt;深入理解java虚拟机&lt;/a&gt;》，说是照抄一遍也不为过。不过作者自己也加入了一些图文用来帮助理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对象是否存活&quot;&gt;&lt;a href=&quot;#对象是否存活&quot; class=&quot;headerlink&quot; title=&quot;对象是否存活&quot;&gt;&lt;/a&gt;对象是否存活&lt;/h2&gt;&lt;p&gt;​        在堆中存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，那些已经“死去”(即不能再被任何途径使用的对象)。
    
    </summary>
    
    
      <category term="jvm" scheme="https://yingu.site/categories/jvm/"/>
    
      <category term="垃圾回收" scheme="https://yingu.site/categories/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="jvm" scheme="https://yingu.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解java虚拟机】-- 自动内存管理机制</title>
    <link href="https://yingu.site/2020/03/29/jvm-MemoryManagement/"/>
    <id>https://yingu.site/2020/03/29/jvm-MemoryManagement/</id>
    <published>2020-03-29T08:34:22.000Z</published>
    <updated>2021-07-18T12:31:14.993Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列内容，大量引用自《<a href="https://book.douban.com/subject/6522893/">深入理解java虚拟机</a>》，说是照抄一遍也不为过。不过作者自己也加入了一些图文用来帮助理解。</p></blockquote><h2 id="java内存区域与内存溢出异常"><a href="#java内存区域与内存溢出异常" class="headerlink" title="java内存区域与内存溢出异常"></a>java内存区域与内存溢出异常</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>​        java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机的进程的启动而存在，有的预取则依赖用户线程的启动和结束而销毁。<a id="more"></a></p><p>​        Java虚拟机所管理的内存包括以下几个运行时数据区域：（下图中图形大小，不代表实际大小比例，只表示相对关系）</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F%E5%9B%BE%E5%AF%B9%E6%AF%94.png" alt=""></p><p>​        从上面的图可以清晰的看出，jdk1.8之后取消了方法区，本地内存中增加了一个元空间。jdk1.8中方法区由元空间实现，现在的元空间可以看作之前的方法区(也称为永久代)。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><blockquote><p>程序计数器是一块较小的内存空间。它可以看作是当前线程锁执行字节码的行号指示器。在虚拟机的概念中，字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p></blockquote><p>​        由于java虚拟机中多线程的实现，因此每一个线程都有自己独立的程序处理器，保证各线程之间计数器不受影响。</p><blockquote><p>如果线程执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行的是native方法，这个计数器则为空(null)。此内存区域是唯一一个在java虚拟机规范中没有规定任何<code>OutOfMemotyError</code>情况的区域。</p></blockquote><h4 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h4><blockquote><p>与程序计数器一样，java虚拟机栈也是线程私有的。他的生命周期与线程相同，虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame，可以这么理解栈帧，虚拟机栈包含N个栈帧每个栈帧包含局部变量表,操作数栈，动态链接，方法出口等信息）。每个方法从调用到执行完成这个过程，就对应这一个栈帧在虚拟机栈中的入栈到出栈的过程。</p></blockquote><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt=""></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><blockquote><p>局部变量表存放了编译期可知的各种基本数据类型（boolean,byte,char,short,int,float,long,double），对象引用（reference类型，他不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和<code>returnAddress</code>类型（指向了一条字节码指令的地址） </p><p>其中64位长度的long和double类型会占用2个局部变量空间，其余的数据类型只会占用1个局部变量空间。局部变量表所需的内存空间在编译期间完成内存分配，当进入一个方法时，这个方法需要在帧中分配多大的内存空间是完全确定的，在方法运行期间不会改变局部变量表的大小。<br>在java虚拟机规范中，对这个区域规定了两种异常状态：如果线程请求的栈的深度大于虚拟机允许的深度，将抛出StackOverFlowError异常（栈溢出），如果虚拟机栈可以动态扩展（现在大部分java虚拟机都可以动态扩展，只不过java虚拟机规范中也允许固定长度的java虚拟机栈），如果扩展时无法申请到足够的内存空间，就会抛出OutOfmMemoryError异常（没有足够的内存）</p></blockquote><p>操作数栈、动态链接，方法出口后面的章节会讲到。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>​        本地方法栈与虚拟机栈所发挥的作用是相似的。区别在于虚拟机栈是为java方法服务，而本地方法栈则为虚拟机使用的native方法服务。<code>HotSpot</code>虚拟机中将本地方法栈和虚拟机栈合二为一。与虚拟机栈一样本地方法栈也会抛出<code>StackOverFlowError</code>和<code>OutOfmMemoryError</code>异常。</p><h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>​        堆是被所有线程共享的一块内存区域，也是java虚拟机中管理的最大一块区域。几乎所有的对象实例都在这里分配，java虚拟机中虽然规定，所有的对象实例以及数组都需要在堆上分配，但是随着JIT编译器的发展与逃逸技术逐渐成熟，栈上分配、标量替换技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><p>​        java栈与堆相比，java栈存储速度比较块，但由于存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p><p>​        堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>​        方法区也被称作为”永久代“，与堆一样方法区也是线程共享的内存区域。用来存储类的信息，例如：方法，方法名，返回值，常量。当它无法满足内存分配需求时，方法区会抛出OutOfMemoryError。</p><p>​        jdk1.7以后取消了方法区，用元空间替代。类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。这样的好处就是元空间不会受到堆内存大小的限制，只跟本地内存有关，所以不会出现永久代存在时的内存溢出问题。但也不能滥用，不然会耗尽本地内存。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>常量池</strong>：class文件常量池，是class文件的一部分，用于保存编译时确定的数据。</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt=""></p><p><strong>运行时常量池</strong>：</p><p>　　Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。<strong>类加载后，常量池中的数据会在运行时常量池中存放</strong>！</p><p><strong>字符串常量池</strong>：</p><p>​        HotSpot VM里，记录<code>interned string</code>的一个全局表叫做<code>StringTable</code>，它本质上就是个<code>HashSet&lt;String&gt;</code>。注意<strong>它只存储对<code>java.lang.String</code>实例的引用，而不存储<code>String</code>对象的内容</strong></p><p>jdk 1.7后，移除了方法区，<strong>字符串常量池依旧保持在堆中，常量池移动到元空间中了</strong>。</p><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>​        Meta Space是JDK1.8引入的，在JDK1.8使用的是方法区，永久代（Permnament Generation）。<br>元空间存储的是元信息，使用的是操作系统的本地内存（Metaspace与PermGen之间最大的区别），可以是不连续的，由元空间虚拟机进行管理。可以产生OutOfMemoryError。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><blockquote><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p></blockquote><h3 id="hospot虚拟机对象探秘"><a href="#hospot虚拟机对象探秘" class="headerlink" title="hospot虚拟机对象探秘"></a>hospot虚拟机对象探秘</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p><strong>new指令：</strong>虚拟机遇到一条new的指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号代表的类是否已被加载、解析和初始化过。如果没有，那么先执行相对于的类加载过程。类加载检查后，接下来虚拟机将对新生对象分配内存。</p><h5 id="分配内存："><a href="#分配内存：" class="headerlink" title="分配内存："></a>分配内存：</h5><ul><li><p>指针碰撞：假设java堆中内存时绝对规整的，所有用过的内存放在一边，空闲的放到另外一边，中间放一个指针做为分界点的指示器，那么分配内存仅仅只需要将指针往空闲空间的那边移动与对象大小相等的距离。</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E.png" alt=""></p></li><li><p>空闲列表：如果java堆中内存并不是规整的，已使用和未使用的互相交错，那么就没办法使用指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，再分配时找到一块足够大的空间，分给对象实例并记录为已使用。</p></li></ul><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8.png" alt=""></p><p>使用哪种方式是由堆是否规整来决定的，而堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p>使用<strong>指针碰撞</strong>来分配从内存的收集器：</p><p>​    Serial、ParNew等带Compact过程的收集器</p><p>使用<strong>空闲列表</strong>来分配从内存的收集器：</p><p>​    CMS这种基于Mark-Sweep算法(标记-清除算法)的收集器</p><p>​        除了如何划分可用空间外，对象的创建是否频繁也是考虑一个点。即使是修改指针位置，在并发情况下也会出现，A在计算完需要分配的内存还未移动后，B又使用原来的指针分配内存。而解决这种情况有两种方法：</p><ol><li>采用cas+失败重试机制，保证更新的原子性（跟java中，AQS中获取锁方式一样，通过cas修改状态值，失败后，循环重试，直到成功或抛出异常为止）</li><li>把内存分配的动作按照线程划分到不同的空间中进行，即每个线程在java堆中预分配一块较小的区域，成为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)。哪个线程需要分配内存，就在那个线程的TLAB上分配，只有TLAB用完了并分配新的TLAB时，才需要锁定。是否使用TLAB,可以通过-XX:+/-UseTLAB参数来设置。</li></ol><p><strong>初始化：</strong>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为0值(不包括对象头)。如果使用TLAB,这一工作过程也可以提前至TLAB分配时进行。这一步保证了对象的实例字段在java代码中不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>对象的初始设置：</strong>接下来虚拟机要对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄。这些信息存放在对象头中(Object Header)。根据当前虚拟机运行状态不同是否需要启用偏向锁等，对象头会有不同的设置。</p><p><strong>init方法：</strong>上面的工作都完成之后，从虚拟机的角度看，一个新的对象已经产生了，但是从java的角度来看，对象的创建才刚刚开始，init方法还没有执行，所有的字段都还为零，所以一般来说执行new指令之后会接着执行init方法，这时候才算真正完成对象的创建。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>​        在Hotspot虚拟机中，对象在内存中储存的布局可以分配三块区域：对象头(Object Header)、实例数据(Instance Data)和对其填充(Padding)。</p><p>​        Hotspot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。</p><blockquote><p>以下描述，引用自<a href="https://www.cnblogs.com/duanxz/p/4967042.html">https://www.cnblogs.com/duanxz/p/4967042.html</a></p></blockquote><table style="text-align:center">      <tr style="background-color:#66B3FF">          <td rowspan="2">锁状态</td>          <td colspan="2">25bit</td>          <td rowspan="2">4bit</td>            <td>1bit</td>            <td>2bit</td>            </tr >    <tr style="background-color:#66B3FF">          <td>23bit</td>          <td>2bit</td>          <td>是否偏向锁</td>            <td>锁标志位</td>        </tr >    <tr>          <td style="background-color:#66B3FF">轻量级锁</td>          <td colspan="4">指向栈中锁记录的指针</td>          <td>00</td>        </tr >    <tr>          <td style="background-color:#66B3FF">重量级锁</td>          <td colspan="4">指向互斥量(重量级锁)的指针</td>          <td>10</td>       </tr >    <tr>          <td style="background-color:#66B3FF">GC标记</td>          <td colspan="4">空</td>          <td>11</td>       </tr >    <tr>          <td style="background-color:#66B3FF">偏向锁</td>          <td>线程ID</td>          <td>Epoch</td>         <td>对象分代年龄</td>         <td>1</td>         <td>01</td>       </tr >  </table><p> <strong>HotSpot虚拟机对象头Mark Word</strong></p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀(重量级锁定)</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><p>​        对象头的另一部分是类型指针，即元素指向它的类元数据的指针，虚拟机通过这个指针来确定是哪个对象的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话来说，查找对象的元数据信息并不一定要经过对象本身，<strong>另外如果对象是一个java数组，那么对象头还必须有一块用于记录数组长度的数据</strong>，因为虚拟机可以通过普通对象的元数据信息确定java对象的大小，但是从数据的元数据中却无法确认数组的大小。</p><blockquote><ul><li>Mark Word(标记字段)：对象的Mark Word部分占4个字节，其内容是一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。</li><li>Klass Pointer（Class对象指针）：Class对象指针的大小也是4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址</li><li>对象实际数据：这里面包括了对象的所有成员变量(无论是从父类继承下来的，还是子类中定义的)，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节。</li><li>对齐：最后一部分是对齐填充的字节，按8个字节填充。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</li></ul></blockquote><p>Mrak Word 三大作用：</p><ul><li>记录锁信息，通过更改锁标志加锁</li><li>记录GC信息，由于Mrak Word中只为对象分代年龄分配了4bit，所以记录的最大数也就是1111，转换为十进制也就是15，所以锁年龄最大为15。</li><li>记录hashcode(identifyHashCode)</li></ul><blockquote><p>System类提供一个identifyHashCode(Object o)的方法，该方法返回指定对象的精确hashCode值，也是根据该对象的地址计算得到的HashCode值。当某个类的hashCode()方法被重写之后，该类实例的hashCode()的方法就不能唯一标识该对象。但是通过identifyHashCode()方法返回的依然是hashCode()值，依然是根据该对象的地址计算得到 hashCode值。所以两个对象的identifyHashCode()值相同，该对象就绝对是一个对象</p></blockquote><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>​        建立对象是为了使用对象，我们的java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义通过何种方式去定位、访问堆中的对象的具体位置，所以对象的访问方式也是由虚拟机实现而定的。目前主流方式有使用句柄和直接指针两种。(hotspot使用的直接指针)</p><ol><li><p>句柄：java堆中划分一块内存出来锁为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的地址信息。使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p></li><li><p>直接指针：java堆对象布局中就必须考虑如何放置类型数据的相关信息，而reference中存储的直接就是对象地址。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。HotSpot使用的是直接指针这种方式访问对象的。</p><p>下图为jdk 1.7中，两种访问方式定位的内存结构图，为了方便描述，将reference一分为二，实际中只会有一个reference。</p></li></ol><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png" alt=""></p><p>放一张自己翻阅资料后，画的一张JVM内存结构图。<br><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/jvm%E5%85%A8%E5%B1%80%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p><p>如果有错误，还请在评论区中指出哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列内容，大量引用自《&lt;a href=&quot;https://book.douban.com/subject/6522893/&quot;&gt;深入理解java虚拟机&lt;/a&gt;》，说是照抄一遍也不为过。不过作者自己也加入了一些图文用来帮助理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;java内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#java内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;java内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;java内存区域与内存溢出异常&lt;/h2&gt;&lt;h3 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h3&gt;&lt;p&gt;​        java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机的进程的启动而存在，有的预取则依赖用户线程的启动和结束而销毁。
    
    </summary>
    
    
      <category term="jvm" scheme="https://yingu.site/categories/jvm/"/>
    
      <category term="内存" scheme="https://yingu.site/categories/jvm/%E5%86%85%E5%AD%98/"/>
    
    
      <category term="jvm" scheme="https://yingu.site/tags/jvm/"/>
    
      <category term="内存" scheme="https://yingu.site/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>【线程池】-- ThreadPoolExecutor源码解析(下)(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/20/ThreadPoolExecutor-2/"/>
    <id>https://yingu.site/2020/03/20/ThreadPoolExecutor-2/</id>
    <published>2020-03-20T08:11:11.000Z</published>
    <updated>2021-07-18T12:31:14.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        上一章我们主要通过<code>execute()</code>方法，来展开分析线程池的运作机制，这一章我们就来看看线程池中<code>submit()</code>这个具有返回值的方法是如何是实现的，又是如何获取返回值的。<a id="more"></a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="AbstractExecutorService类"><a href="#AbstractExecutorService类" class="headerlink" title="AbstractExecutorService类"></a>AbstractExecutorService类</h3><p><code>ThreadPoolExecutor</code>继承自<code>AbstractExecutorService</code>类，而<code>submit()</code>方法就在父类<code>AbstractExecutorService</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过传入的Runnable,value来构造一个RunnableFuture，</span></span><br><span class="line">    <span class="comment">//runnable作为线程执行的任务，value作为返回值</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将Runnable包装成一个FutureTask返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于Callable本身就有返回值，因此不用指定</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将Callable包装成一个FutureTask返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交一个任务返回一个Future，通过Future.get()方法可以获取返回值null</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//提交一个任务返回一个Future，通过Future.get()方法可以获取返回值result</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交一个任务返回一个Future，通过Future.get()方法可以获取Callable中的返回值</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                <code>Callable</code>是一个接口，里面声明了一个具有返回值的<code>call()</code>方法，类似<code>Runnable</code>中的<code>run()</code>方法，不同的是<code>call()</code>方法具有返回值，并且可以抛出异常。</p><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>AbstractExecutorService</code>中的<code>submit()</code>方法可以看到，无论当你传入一个<code>Runnable</code>还是<code>Callable</code>，最终都会包装成一个<code>FutureTask</code>返回，我们看看<code>FutureTask</code>里面的结构：</p><h3 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h3><h4 id="FutureTask类结构"><a href="#FutureTask类结构" class="headerlink" title="FutureTask类结构"></a>FutureTask类结构</h4><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/FutureTask.png" alt=""></p><p>从<code>FutureTask</code>结构图看到，<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，而<code>RunnableFuture</code>又继承了<code>Runnable</code>和<code>Future</code>接口，因此<code>FutureTask</code>也具有<code>RunnableFuture</code>的特点，在成功执行<code>run()</code>方法后，可以通过<code>Future</code>访问执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//任务新建正在执行中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//任务即将完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//任务正常执行完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//任务异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//任务线程被取消</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//任务线程将被中断</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//任务线程已被中断</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储传入的任务</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">//保存get方法返回的结果，也有可能保存的是一个异常</span></span><br><span class="line">    <span class="comment">//这里没有使用volatile修饰，意欲何为</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">    <span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line">    <span class="comment">//执行任务的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line">    <span class="comment">//等待节点，多个节点组成一个链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="comment">//如果正常执行，返回任务结果</span></span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="comment">//如果任务被取消，抛出任务CancellationException异常</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="comment">//抛出任务执行ExecutionException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Callable来构造一个FutureTask</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">//初始状态为NEW</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过FutureTask来构造一个FutureTask,result作为方法执行后的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Executors.class中的方法，通过RunnableAdapter将Runnable适配为一个Callable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Executors.class的内部类，RunnableAdapter实现了Callable接口</span></span><br><span class="line">    <span class="comment">//通过传入Runnable构造一个Callable，当使用Callable.call时，实际上</span></span><br><span class="line">    <span class="comment">//执行的是Runnable的run方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//检查任务是否被取消</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;= CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查任务是否执行完毕</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state != NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消任务，mayInterruptIfRunning为false表示不允许在线程运行时中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果任务状态为NEW，如果允许中断运行中的线程，那么将任务状态设置为INTERRUPTING</span></span><br><span class="line">        <span class="comment">//否则设置为CANCELLED，如果设置失败，直接返回false</span></span><br><span class="line">        <span class="comment">//如果任务状态不为NEW，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="comment">//如果允许在线程运行时候取消</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//中断线程，中断后会唤醒waiters上等待获取该任务结果的线程</span></span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    <span class="comment">//将线程状态设置为INTERRUPTED</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//执行任务完成方法</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取消成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取任务执行完成之后的返回值，响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//如果任务还未完成</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">//那么阻塞等待</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时获取任务执行完成之后的返回值，响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//如果任务还未完成，那么阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过cas设置任务的状态为即将完成状态，成功后记录返回值</span></span><br><span class="line">    <span class="comment">//将任务最终状态置为NORMAL</span></span><br><span class="line">    <span class="comment">//执行finishCompletion()方法完成任务</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">//记录返回值</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">//设置任务最终状态为正常执行</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            <span class="comment">//完成任务</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过cas设置任务的状态为即将完成状态，设置成功后</span></span><br><span class="line">    <span class="comment">//记录异常作为返回值，设置任务最终状态为EXCEPTIONAL</span></span><br><span class="line">    <span class="comment">//执行finishCompletion()方法完成任务</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">//记录返回值为异常</span></span><br><span class="line">            outcome = t;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果任务状态不为NEW，或者执行任务的不是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取任务</span></span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">//任务状态为NEW的时候才执行</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="comment">//是否正常执行</span></span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//如果发生异常，设置异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    <span class="comment">//正常执行后设置</span></span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            <span class="comment">//执行任务的线程置为null</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">//如果线程被中断</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过该方法可以执行多次任务，任务执行完成后不会修改线程状态，并且不会设置返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果状态不为NEW或者更改任务线程为当前线程失败，那么直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//不设置返回结果</span></span><br><span class="line">                    c.call(); <span class="comment">// don't set result</span></span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            s = state;</span><br><span class="line">            <span class="comment">//如果任务即将被中断</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                <span class="comment">//等待任务变为中断状态</span></span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待任务变为中断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">        <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">        <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">            <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">                Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成任务操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">        <span class="comment">//如果有线程在等待任务结果</span></span><br><span class="line">        <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="comment">//将链表设置为null,然后释放等待节点中的线程</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    Thread t = q.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        q.thread = <span class="keyword">null</span>;</span><br><span class="line">                        LockSupport.unpark(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    WaitNode next = q.next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                    q = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        done();</span><br><span class="line"></span><br><span class="line">        callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待完成</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//计算超时时间，如果未设置超时deadline为0</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//如果当前线程被中断，那么从等待节点中移除</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="comment">//抛出中断异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">//如果任务已经完成</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//返回任务状态</span></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果任务即将完成，那么让给cpu资源</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="comment">//如果等待链表不存在，设置等待节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="comment">//将q放置到waiters前面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="comment">//如果设置超时了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">//判断是否超时，如果超时移除等待节点，返回任务状态</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//超时阻塞</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果未设置超时，那么直接阻塞</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除等待节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.thread = <span class="keyword">null</span>;</span><br><span class="line">            retry:</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">                <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                    s = q.next;</span><br><span class="line">                    <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                        pred = q;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pred.next = s;</span><br><span class="line">                        <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                            <span class="keyword">continue</span> retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                          q, s))</span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = FutureTask<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">            runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"runner"</span>));</span><br><span class="line">            waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"waiters"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们基本知道了，调用<code>submit()</code>方法来执行、获取返回值的一个过程，我们来回顾一下：</p><ol><li>通过<code>submit()</code>来提交一个任务，无论提交的是<code>Runnable</code>还是<code>Callable</code>，最终都会包装为一个<code>FutureTask</code>对象，<code>FutureTask</code>内部有一个<code>Callable</code>用于存储任务，<code>Callable</code>的<code>call()</code>会返回一个执行结果，<code>FutureTask</code>通过<code>get()</code>方法可以获取到<code>Callable</code>任务正常执行完成后的一个结果</li><li><code>Callable</code>的<code>call()</code>方法有结果，而我们<code>Runnable</code>的<code>run()</code>方法没有返回结果, 因此当我们通过<code>submit</code>传入一个<code>Runnable</code>时，会通过<code>FutureTask</code>的构造方法使用<code>Executors.callable(runnable, result)</code>将传入的<code>Runnable</code>适配<code>Callable</code>，创建一个<code>RunnableAdapter</code>适配器，并且以<code>result</code>作为它的返回值。</li><li><code>FutureTask</code>通过<code>get()</code>方法到任务正常执行完成后的一个结果，如果任务此时还未完成，那么会调用<code>awaitDone()</code>方法创建一个<code>WaitNode</code>等待节点，并将它加入到以<code>WaitNode</code>组成的waiters链表的头部。</li><li>当任务执行正常执行完成后，会移除并释放在<code>waiters</code>上等待的节点线程，线程被唤醒后，如果发现结束，那么<code>report</code>判断是否正常结束，如果正常返回<code>result</code>结果，否则抛出异常。如果任务执行中被中断，那么移除waiters上等待该结果的节点，抛出异常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        上一章我们主要通过&lt;code&gt;execute()&lt;/code&gt;方法，来展开分析线程池的运作机制，这一章我们就来看看线程池中&lt;code&gt;submit()&lt;/code&gt;这个具有返回值的方法是如何是实现的，又是如何获取返回值的。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="线程池" scheme="https://yingu.site/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【线程池】-- ThreadPoolExecutor源码解析(上)(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/19/ThreadPoolExecutor-1/"/>
    <id>https://yingu.site/2020/03/19/ThreadPoolExecutor-1/</id>
    <published>2020-03-19T03:01:21.000Z</published>
    <updated>2021-07-18T12:31:14.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线程池就是一个缓存的概念，将使用完的线程放入到线程池中管理，这样有下一个任务需要执行时，直接从线程池中获取线程执行就行，避免重复的执行线程创建、销毁操作，做到线程复用，从而提高线程的利用率，还能通过线程池来对执行任务的线程进行控制，避免线程被滥用。<a id="more"></a>java中通过<code>Executors</code>类提供了多种实现线程池的方式，以下列举常用的四种：</p><ol><li><code>newFixedThreadPool</code>： 创建一个可重用固定线程数的线程池 </li><li><code>newSingleThreadExecutor</code> :   创建一个使用单个线程的线程池。 </li><li><code>newCachedThreadPool</code>： 创建一个可根据需要创建新线程的线程池</li><li><code>newScheduledThreadPool</code>：  创建一个任务可延迟的线程池</li></ol><p>以上创建线程池方法，都是以<code>ThreadPoolExecutor</code>为基础，等本章解析完，再来介绍上面几种创建线程池的用法。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/ThreadPoolExecutor.png" alt=""></p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用高3位存储线程池工作状态，使用低29位保存工作线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//29位，用于位于操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//低29位用于保存线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高3位：111：接受新任务并且继续处理阻塞队列中的任务(负数位移，高位补1)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">//高3位：000：不接受新任务但是会继续处理阻塞队列中的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">//高3位：001：不接受新任务，不在执行阻塞队列中的任务，中断正在执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">//高3位：010：所有任务都已经完成，线程数都被回收，线程会转到TIDYING状态会继续执行模板方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">//高3位：110：线程会转到TIDYING状态后，会执行模板方法，执行完毕后转为TERMINATED状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来保存等待被执行的任务的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储工作任务的集合，每次针对workers操作都需要加锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录同时运行过的最大工作线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程的工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造线程持时如果未指定拒绝策略，会使用该策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否允许核心线程超时，默认为false,只有非核心线程才会超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大线程数，当前阻塞队列满了后，提交的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认执行的拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">        <span class="keyword">new</span> AbortPolicy();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">        <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker内部类"><a href="#Worker内部类" class="headerlink" title="Worker内部类"></a>Worker内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自AQS、实现了Runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个worker有自己的内部线程，ThreadFactory创建失败时为null</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//初始化任务，可能为null</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//完成任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Worker构造方法，传入一个Runnable</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;禁止线程在runWorker前被打断</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">//通过工厂创建线程，传入自身，</span></span><br><span class="line">        <span class="comment">//因此通过thread.start后会调用Worker的run方法</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Runnable的run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行任务，传入Worker自身</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否被持有</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;2&gt;.不允许重入</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//直接设置为0</span></span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果线程已经开始了，那么中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Worker</code>继承自<code>AQS</code>、实现了<code>Runnable</code>，通过使用<code>AQS</code>来实现锁，从上面代码，可以获取到的几条信息：</p><ol><li><code>Worker</code>创建时就已经上锁了</li><li><code>Worker</code>锁不允许重入</li><li><code>Worker</code>内部<code>thread</code>创建时，传入的是<code>Worker</code>自身</li></ol><p>以下问题建议先看完后面解析，再回来看，或者你可以带着问题先往下看。</p><p><strong>为什么<code>Worker</code>在创建的时候就需要上锁呢?</strong></p><ul><li>从<code>interruptIdleWorkers()</code>方法就知道，任务未开始或者正在执行的时候不应该被中断，通过锁的状态来表示任务的运行状态</li><li>在<code>runWorker()</code>之前，<code>Worker</code>的锁状态一直为-1，表示未开始。随后<code>runWorker()</code>方法会释放<code>Worker</code>的锁，将它状态变为-1，表示可以被中断。获取到任务后<code>runWorker()</code>又会获取锁，表示任务正在执行，不可被中断，并且不可并发执行，此时锁状态为1。</li><li>所以<code>Worker</code>锁有三种状态：-1表示<code>Worker</code>被初始化后还未执行，不可被中断；0表示<code>Worker</code>准备开始执行(可被中断)或者已经执行结束；1表示<code>Worker</code>正在执行，不可被中断。</li></ul><p><strong>为什么<code>Worker</code>锁不允许重入?</strong></p><ul><li>如果<code>Worker</code>为重入锁，那么<code>runWorker()</code>中反复执行阻塞队列中的任务的时候， 就有可能同一个线程同时执行多个任务。</li></ul><p><strong>为什么<code>Worker</code>内部<code>thread</code>创建时，传入的是<code>Worker</code>自身？</strong></p><ul><li>用户调用<code>execute()</code>方法,执行一个任务时，会传入一个<code>Runnable</code>，通过<code>addWorker()</code>方法后，会通过<code>Runnable</code>创建一个<code>Worker</code>，因此<code>Worker</code>内部既有一把锁，也有一个<code>Runnable</code>任务，执行<code>thread.start</code>时，实际上执行的是<code>Runnable</code>中的任务，而<code>Worker</code>又可以作为一把锁，保证执行的任务不会被中断</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="ctl相关方法"><a href="#ctl相关方法" class="headerlink" title="ctl相关方法"></a>ctl相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据ctl计算runState，使用&amp;运算时，~CAPACITY表示只有高3位参与了计算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 根据ctl计算workerCount，表示只有低29位参与了计算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 根据runState和workerCount计算clt值，rs的高3位与wc的低29通过|计算就是ctl的结果</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作线程数+1，失败返回false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作线程数-1，失败返回false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作线程数-1，直到成功为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程池是否被关闭的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该构造方法无需指定线程工厂，使用默认线程工厂defaultThreadFactory</span></span><br><span class="line"><span class="comment">//该构造方法无需指定拒绝策略，使用默认的defaultHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造方法无需指定拒绝策略，使用默认的defaultHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造方法无需指定线程工厂，使用默认线程工厂defaultThreadFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//corePoolSize：核心线程数</span></span><br><span class="line"><span class="comment">//maximumPoolSize：最大线程数</span></span><br><span class="line"><span class="comment">//keepAliveTime：线程存活时间</span></span><br><span class="line"><span class="comment">//unit：线程存活时间单位</span></span><br><span class="line"><span class="comment">//workQueue：线程等待队列</span></span><br><span class="line"><span class="comment">//threadFactory：线程工厂</span></span><br><span class="line"><span class="comment">//handler： 拒绝策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> :</span><br><span class="line">    AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该类在Executors.class中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="submit方法"><a href="#submit方法" class="headerlink" title="submit方法"></a>submit方法</h3><p><code>submit()</code>方法在父类<code>AbstractExecutorService.clss</code>中，跟<code>execute()</code>方法不同的是<code>submit()</code>方法有返回值。通过返回的<code>Future</code>对象调用它的<code>Future.get()</code>方法，可以获取到任务执行完成后的返回值。</p><p>本章主要通过<code>execute()</code>方法，来展开分析线程池的运作机制，因此<code>submit()</code>方法具体细节留到了下一章</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable没有返回值</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//将Runnable包装成RunnableFuture，Runnable没有返回值，默认返回null</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//最终还是执行的execute(Runnable command)方法</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Runnable没有返回值，可以指定一个result作为Runnable返回值，</span></span><br><span class="line"><span class="comment">//任务完成后可以通过Future.get()获取到result</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Callable自带返回值，任务完成后可以通过Future.get()获取到Callable中的返回值</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p>执行一个任务，大致分为三步：</p><ol><li>当工作线程数小于核心线程数时，会通过<code>addWorker(command, true)</code>新建一个核心线程执行任务，成功后直接返回</li><li>如果核心线程没有空闲，且线程池还处于运行状态，那么通过<code>workQueue.offer(command)</code>将任务添加到阻塞队列 <code>BlockingQueue</code> 中等待执行，重新检查线程池状态后，如果此时线程池被关闭了，那么 <code>remove(command)</code>移除刚才添加的任务，如果未关闭，判断是否存在工作线程，如果不存在那么添加一个非核心线程执行任务,用于执行刚才<code>offer</code>到队列中的任务。</li><li>通过<code>addWorker(command, false)</code>创建一个非核心线程执行任务，如果失败，说明线程达到最大线程数，那么执行拒绝策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">//检查当前线程池状态</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//&lt;1&gt;.如果工作线程小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//创建一个核心线程来执行当前command，如果执行成功，直接返回</span></span><br><span class="line">        <span class="comment">//返回false，说明添加任务被拒绝了，或者command未执行</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//检查线程池状态</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&lt;2&gt;.如果当前为运行状态，添加任务到阻塞队列中，如果失败说明阻塞队列已满</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//重新检查线程池状态，因为状态有可能被其他线程操作改变</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//如果不是运行状态，被其他线程给中断了，移除刚刚添加到阻塞队列中的任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">//移除成功后执行拒绝方法</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果是运行状态但是没有线程来执行这个任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//创建一个非核心线程执行任务，传入的firstTask为null，</span></span><br><span class="line">            <span class="comment">//是因为刚才通过offer已经将任务添加到阻塞队列中了，直接去队列中获取任务就行了</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&lt;3&gt;如果阻塞队列也满了，那么创建一个非核心线程执行任务</span></span><br><span class="line">    <span class="comment">//失败说明超过了最大线程数，那么执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">//详解看下面拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将任务从队列中移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    <span class="comment">//尝试终止线程池</span></span><br><span class="line">    tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p>添加一个工作线程用于执行任务，<code>firstTask</code>表示要执行的任务(可以为null )，<code>core</code>表示是否使用核心线程来作为是否新建任务的条件。那么通过传入不同的参数，有以下四种情况，<code>execute</code>方法用到了下面的三种：</p><ol><li><code>addWorker(command, true)</code>：创建核心线程来执行<code>command</code>任务，如果核心线程没有空闲，那么返回<code>false</code></li><li><code>addWorker(null, false)</code>：创建非核心线程来执行阻塞队列<code>workQueue</code>中的任务，如果已经达到最大线程数，那么返回<code>false</code></li><li><code>addWorker(command, false)</code>：创建非核心线程来执行<code>command</code>任务，如果已经达到最大线程数，那么返回<code>false</code></li><li><code>addWorker(null, true)</code>，创建核心线程来执行阻塞队列<code>workQueue</code>中的任务，如果核心线程没有空闲，那么返回<code>false</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">     retry:</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">//检查线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         <span class="comment">//获取运行状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *  1.rs &gt;= SHUTDOWN 表示线程已关闭,不能接受新的任务</span></span><br><span class="line"><span class="comment">          *   2.如果rs != SHUTDOWN,说明线程状态为STOP, TIDYING或TERMINATED的时候</span></span><br><span class="line"><span class="comment">          *   这个时候不会接受新的任务，直接返回false</span></span><br><span class="line"><span class="comment">          *   3.firstTask != null(表示为新的任务),线程状态为SHUTDOWN，</span></span><br><span class="line"><span class="comment">          *   但是firstTask != null的时候，也不能接受任务</span></span><br><span class="line"><span class="comment">          *   4.线程状态为SHUTDOWN，并且firstTask == null</span></span><br><span class="line"><span class="comment">          *   但是等待线程为空的时候（说明等待队列中已经没有可执行的任务了），也不能接受新的任务</span></span><br><span class="line"><span class="comment">          *   5.总结下来就是，如果rs为SHUTDOWN，只有firstTask == null，并且等待线程不为空的时候</span></span><br><span class="line"><span class="comment">          *   才能接受本次添加工作任务的操作，这样也跟上面说的语义符合：SHUTDOWN不接受新任务但是</span></span><br><span class="line"><span class="comment">          *   会继续处理阻塞队列中的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">             ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//自旋重试</span></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="comment">//记录工作线程数</span></span><br><span class="line">             <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">             <span class="comment">//1.wc &gt;= CAPACITY，如果大于或者等于最大容量了，返回false</span></span><br><span class="line">             <span class="comment">//2.是创建核心线程，如果是，判断当前数量是否大于等于核心线程数，</span></span><br><span class="line">             <span class="comment">//否则判断是否大于等于最大线程数</span></span><br><span class="line">             <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                 wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">//工作线程+1，失败说明工作线程的值被其他线程改变了，跳出当前循环</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">break</span> retry;</span><br><span class="line">             <span class="comment">//重新获取线程池状态，因为状态有可能被其他线程改变</span></span><br><span class="line">             c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">             <span class="comment">//如果运行状态被改变了，重试</span></span><br><span class="line">             <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                 <span class="keyword">continue</span> retry;</span><br><span class="line">             <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务是否开始</span></span><br><span class="line">     <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//是否成功添加了任务</span></span><br><span class="line">     <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">     Worker w = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//创建一个新的任务线程</span></span><br><span class="line">         w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">         <span class="comment">//获取执行任务线程（由线程工厂创建，可能会失败）</span></span><br><span class="line">         <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">         <span class="comment">//如果创建线程失败，会进入到finally中执行addWorkerFailed方法</span></span><br><span class="line">         <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">             <span class="comment">//加锁，避免出现并发问题</span></span><br><span class="line">             mainLock.lock();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                 <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                 <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                 <span class="comment">//检查运行状态</span></span><br><span class="line">                 <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"> <span class="comment">//1.线程池状态为RUNNING</span></span><br><span class="line">                 <span class="comment">//2.线程池状态为SHUTDOWN，并且firstTask == null</span></span><br><span class="line">                 <span class="comment">//前面说了firstTask == null表示任务已经加入到阻塞队列中了，直接去取任务就行了</span></span><br><span class="line">                 <span class="comment">//说明线程池在SHUTDOWN状态下，也能执行阻塞队列中的任务</span></span><br><span class="line">                 <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                     (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                     <span class="comment">//线程还没start情况下，如果t的状态为alive，说明线程状态异常</span></span><br><span class="line">                     <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                     <span class="comment">//将要执行的任务记录到workers中，由于workers是一个HashSet，</span></span><br><span class="line">                     <span class="comment">//因此需要lock保证线程安全</span></span><br><span class="line">                     workers.add(w);</span><br><span class="line">                     <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                     <span class="comment">//largestPoolSize替换为较大值,记录线程池创建过的最大线程数</span></span><br><span class="line">                     <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line">                     <span class="comment">//标记创建线程成功</span></span><br><span class="line">                     workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//如果添加了任务，那么执行</span></span><br><span class="line">             <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                 <span class="comment">//最终会调用w的run方法，执行runWorker方法</span></span><br><span class="line">                 t.start();</span><br><span class="line">                 <span class="comment">//标记任务已开始</span></span><br><span class="line">                 workerStarted = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//如果任务没有开始，说明任务没有创建成功</span></span><br><span class="line">         <span class="comment">//那么前面将任务线程数+1的操作就要减掉，如果任务线程已经加入到了workers中，也需要移除</span></span><br><span class="line">         <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">             <span class="comment">//执行任务失败的操作</span></span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>addWorker</code>中方法分为两大步骤：外层的for循环，try代码块</p><p><strong>for循环结束的四种情况：</strong></p><ol><li>线程池状态为<code>SHUTDOWN</code>，并且<code>firstTask != null</code>，直接返回<code>false</code>，结束<code>addWorker</code>方法</li><li>线程池状态为<code>STOP</code>、<code>TIDYING</code>或<code>TERMINATED</code>，直接返回<code>false</code>，结束<code>addWorker</code>方法</li><li>添加到核心线程，如果核心线程没有空闲，那么直接返回false。如果添加到非核心线程，如果超过最大线程数，那么直接返回false</li><li>线程池如果允许添加任务线程，则将工作线程数+1，如果成功跳出for循环，准备执行try代码块中的逻辑</li></ol><p>通过上面三种情况也能看出，for循环的主要作用，确保当前线程池状态允许接收新的任务，如果可以就将工作线程数+1直到成功，否则直接结束<code>addWorker</code>方法。而只有两种情况还能执行下一步，要么线程池状态为<code>RUNNING</code>，要么线程池状态为<code>SHUTDOWN</code>并且<code>firstTask == null</code> 。</p><p><strong>try代码块：</strong></p><ol><li>创建一个任务线程<code>Worker</code>，如果<code>Worker</code>内部通过线程工厂创建失败，那么会直接执行最后的<code>finally</code>块中的 <code>addWorkerFailed(w)</code>方法。</li><li><code>Worker</code>创建成功后，在两种情况下才可以执行任务，要么线程池状态为<code>RUNNING</code>，要么线程池状态为<code>SHUTDOWN</code>，且<code>firstTask == null</code>（表示执行阻塞队列中的任务），否则会执行最后的<code>finally</code>块中的 <code>addWorkerFailed(w)</code>方法。</li><li>将要执行的任务记录到<code>workers</code>集合，由于<code>workers</code>是一个<code>HashSet</code>，因此需要<code>lock</code>加锁保证线程安全</li><li>通过<code>Worker</code>中的<code>Thread.start()</code>启动执行任务，最终会调用<code>runWorker(Worker w)</code>传入当前的<code>Worker</code></li><li>任务创建失败后，也会进入到 <code>addWorkerFailed(w)</code>方法，将任务线程数-1，如果任务线程已经加入到了workers中，也需要移除。</li></ol><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">//记录Worker中的任务，可能为null</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//解锁将w的状态置为0(Worker初始化时会将state置为-1)，表示开始运行，允许被中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">//是否出现异常</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * task != null说明执行的是新的任务</span></span><br><span class="line"><span class="comment">         * (task = getTask()) != null，从阻塞队列中取出一个任务</span></span><br><span class="line"><span class="comment">         * 也就是说如果传入的task为null，并且从阻塞队列中获取不到任务的情况下，就会退出while循环</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *1.如果当前线程池的状态&gt;=STOP,并且未中断任务线程，那么就中断任务线程</span></span><br><span class="line"><span class="comment">             * 2.检查当前线程是否被中断，再次检查线程池的状态，如果&gt;=STOP，</span></span><br><span class="line"><span class="comment">             *并且未中断任务线程，那么就中断任务线程</span></span><br><span class="line"><span class="comment">             *从这一步可以看出，如果线程池的状态&gt;=STOP,那么不会执行阻塞队列中的任务并且中断</span></span><br><span class="line"><span class="comment">             *正在执行任务的线程</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//任务执行之前模板方法</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="comment">//记录异常</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//任务执行后的模板方法</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将task置为null，进入while循环，执行下一次任务</span></span><br><span class="line">                <span class="comment">//这就是线程池回收线程的关键</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//完整任务数+1</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将是否出现异常标记置为false</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//执行最终的退出方法</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>释放<code>Worker</code>中的锁，表示<code>Worker</code>的线程允许被中断</li><li>判断传入的<code>Worker</code>中是否存在<code>task</code>，如果不存在，那么去通过<code>getTask()</code>方法去阻塞队列中获取，如果获取失败，直接执行<code>processWorkerExit(w, completedAbruptly)</code>退出方法</li><li>执行任务前会判断线程池的状态，如果此时线程池的状态为<code>STOP</code>, <code>TIDYING</code>、<code>TERMINATED</code>，并且未中断任务线程，那么就中断任务线程。</li><li>如果第一次检查线程池的状态为<code>RUNNING</code>或者<code>SHUTDOWN</code> ，那么检查当前线程是否被中断，如果被中断，那么再次检查线程池的状态，如果状态为<code>STOP</code>, <code>TIDYING</code>、<code>TERMINATED</code>，并且未中断任务线程，那么就中断任务线程。</li><li>如果线程池状态始终为<code>RUNNING</code>或者<code>SHUTDOWN</code> ，接下来就要准备执行任务，执行任务前会先执行前置<code>beforeExecute(wt, task)</code>模板方法，然后通过<code>task.run()</code>执行任务，任务执行完毕后，会执行后置 <code>afterExecute(task, thrown)</code>方法，无论执行任务期间是否抛出异常，最终都会将task置为null，并且将完成任务数量+1，task置为null后又会进入到while循环，继续从队列中获取任务执行</li><li>整个任务结束前，会执行<code>processWorkerExit(w, completedAbruptly)</code>退出方法。</li></ol><p>通过该方法可以窥探出线程池复用线程的原理，也就是上面的第5步，将task置为null后，当前线程执行任务后不会立马退出，而是经过上面的while循环，继续去阻塞队列中获取未执行的任务，直到队列中不存在任务为止。</p><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从阻塞队列中取出任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上次轮询是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"><span class="comment">//自旋重试</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//检查线程池运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">//仅在必要的时候检查队列是否为空</span></span><br><span class="line">        <span class="comment">//只有在状态为SHUTDOWN时才会检查队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//如果线程池状态为STOP, TIDYING、TERMINATED，或者状态为</span></span><br><span class="line">            <span class="comment">//SHUTDOWN，但是队列为空的时候，就会执行退出</span></span><br><span class="line">            <span class="comment">//工作线程数-1</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="comment">//返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取工作线程数量</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">//当前是否线程是否允许超时</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"><span class="comment">//这几种情况下才可以获取任务</span></span><br><span class="line">        <span class="comment">//1.当前工作线程小于最大线程数并且没有经历过超时</span></span><br><span class="line">        <span class="comment">//2.上次虽然超时了，但是阻塞队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//工作线程数-1，设置失败后重试</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//返回null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//到了这一步说明当前工作线程还未达到最大线程数，并且未经历过超时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果设置了超时，那么超时获取队列中的任务，否则使用take()从队列中获取任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="comment">//如果不为null,任务获取成功，返回任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//标记任务获取超时，进入下一次循环</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">//如果线程被中断，那么将超时标记设为false</span></span><br><span class="line">            <span class="comment">//可能执行了shutdownNow方法</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取任务中有三种情况会结束方法：</p><ol><li>如果线程池状态为<code>STOP</code>, <code>TIDYING</code>、<code>TERMINATED</code>，或者状态为<code>SHUTDOWN</code>，且队列为空的时候，将工作线程数-1，成功后会返回null。</li><li>工作线程大于最大线程的，并且执行工作线程-1操作成功时，将工作线程数-1，成功后会返回null。</li><li>上次获取任务超时并且还存在工作线程时，并且执行工作线程-1操作成功时，将工作线程数-1，成功后会返回null。</li><li>上次获取任务超时并且阻塞队列为空的时候(上次获取任务失败，说明队列中已经没有任务可以获取了，再判断一次，如果没有的话直接退出)</li><li>从阻塞队列中获取到任务，返回队列中的任务</li></ol><p>从上面方法了解到：</p><ol><li>核心线程默认不会超时，除非设置<code>allowCoreThreadTimeOut=true</code></li><li>是否为核心线程只是一个逻辑并不存在具体的标记来划分，当前是否为核心线程，是根据当前活动线程数是否大于核心线程数来判定</li><li>判定结果为非核心线程时，从阻塞队列中获取任务的操作会超时，超时后返回null，会回到<code>runWorker()</code>方法中会跳出while循环，而结束掉该线程。</li><li>判定结果为核心线程时，从阻塞队列中获取任务的操作不会超时，知道获取到值为止，因此一般情况下核心线程不会结束，除非设置<code>allowCoreThreadTimeOut=true</code></li><li>由于判断是否为核心线程是有当前活动线程来决定的，因此任何线程都有可能成为核心线程，之前为核心线程获取到任务之后，下一次执行不一定就是核心线程。</li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当达到最大线程数后，不会在接受新的任务，此时会通过此方法，执行拒绝策略</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过调用RejectedExecutionHandler #rejectedExecution方法</span></span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池自带四种拒绝策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果线程池还处于运行状态，那么使用调用者线程来执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认使用的拒绝策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">//丢弃任务并抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//丢弃任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果线程池还处于运行状态，丢弃阻塞队列尾部的一个任务，将该任务加入到队列尾部</span></span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程持默认提供了四种拒绝策略：</p><ol><li>CallerRunsPolicy：如果线程池还处于运行状态，那么会用调用者的线程执行任务，否则丢弃任务</li><li>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常</li><li>DiscardPolicy：直接丢弃任务</li><li>DiscardOldestPolicy：如果线程池还处于运行状态，丢弃阻塞队列尾部的一个任务，将该任务加入到队列尾部</li></ol><h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试终止线程池，回收线程，每次减少worker或者从队列中移除任务的时候都需要调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//自旋重试</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">//检查线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         <span class="comment">//1.如果线程池为RUNNING运行状态，直接返回</span></span><br><span class="line">         <span class="comment">//2.如果线程池状态为TIDYING、TERMINATED直接返回</span></span><br><span class="line">         <span class="comment">//3.如果线程状态为SHUTDOWN并且workQueue不为空，直接返回</span></span><br><span class="line">         <span class="comment">//也就是说1、2、3种情况，都不会继续执行终止线程池操作</span></span><br><span class="line">         <span class="comment">//只有线程池状态为STOP或者SHUTDOWN且workQueue为空的情况下，才会继续执行</span></span><br><span class="line">         <span class="comment">//终止线程池操作</span></span><br><span class="line">         <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">             runStateAtLeast(c, TIDYING) ||</span><br><span class="line">             (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">//当前线程数不为0时，才有资格终止线程池</span></span><br><span class="line">         <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">             <span class="comment">//中断空闲的任务线程</span></span><br><span class="line">             interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">         <span class="comment">//加锁</span></span><br><span class="line">         mainLock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//将线程池运行状态设置为TIDYING，工作线程数置为0</span></span><br><span class="line">             <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">//执行模板方法</span></span><br><span class="line">                     terminated();</span><br><span class="line">                 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     <span class="comment">//模板方法执行完成后，将线程池状态设置为TERMINATED</span></span><br><span class="line">                     ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                     <span class="comment">//awaitTermination()方法中，会调用termination.awit方法</span></span><br><span class="line">                     termination.signalAll();</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             mainLock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// else retry on failed CAS</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>尝试终止线程池，从这里可以看出线程池状态的变化</p><ul><li><code>SHUTDOWN</code>   一&gt; <code>TIDYING</code>: <code>workQueue</code>为空，且工作线程数为0</li><li><code>STOP</code>一&gt; <code>TIDYING</code>：工作线程数为0</li><li><code>TIDYING</code> 一&gt; <code>TERMINATED</code>: 执行完<code>terminated()</code>后</li></ul><h3 id="interruptIdleWorkers方法"><a href="#interruptIdleWorkers方法" class="headerlink" title="interruptIdleWorkers方法"></a>interruptIdleWorkers方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断空闲的线程(也就是等待从阻塞队列中获取任务的线程)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历workers集合中的所有任务线程</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//如果任务的线程未被中断，那么尝试通过tryLock获取锁</span></span><br><span class="line">            <span class="comment">//线程如果还未开始或者正在执行，不能获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//中断线程</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//解除锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有一个中断完成之后，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorkerFailed方法"><a href="#addWorkerFailed方法" class="headerlink" title="addWorkerFailed方法"></a>addWorkerFailed方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务创建失败后，还原任务创建前执行的其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//加锁，避免多个线程并发中断</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果任务线程存在，从待执行的任务集合中去除</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//工作线程数-1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">//尝试中断线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用runWorker方法完成后，会执行此方法，表示退出 completedAbruptly表示是否出现过异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果程序退出前出现过异常，那么将当前工作线程数-1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//加锁，workers非线程安全</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//统计完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">//将任务线程从workers集合中移除</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"><span class="comment">//检查线程池状态</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程池状态为RUNNING或者SHUTDOWN</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//如果执行的任务没出现异常</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//如果允许核心线程失效，那么为0，否则为核心线程数</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">//如果允许核心线程失效，并且阻塞队列不为空，设置min为1</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果工作线程有一个就返回</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则创建一个任务线程，去执行阻塞队列中还未执行的任务</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h3><p>停止线程池，不会接受新任务，但是会继续处理阻塞队列中的任务，中断没被执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否允许执行shutdown</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//将线程池状态设置为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//中断所有空闲的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">//钩子方法，ScheduledThreadPoolExecutor中重写了</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否允许执行shutdown</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkShutdownAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkPermission(shutdownPerm);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                security.checkAccess(w.thread);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空方法，留给子类实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h3><p>立刻停止线程池，不接受新任务，中断正在执行的任务，不在执行阻塞队列中的任务，并返回阻塞队列中未执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否允许执行shutdown</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//将线程池状态设置为STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//中断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//获取阻塞队列中未执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="comment">//返回阻塞队列中未执行的任务</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">//将阻塞队列中的任务添加到taskList中</span></span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="comment">//确保所有的任务都已经移动到taskList中</span></span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="comment">//从队列中移除</span></span><br><span class="line">            <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                <span class="comment">//添加到taskList中</span></span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interruptWorkers方法"><a href="#interruptWorkers方法" class="headerlink" title="interruptWorkers方法"></a>interruptWorkers方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断所有已启动的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="线程池状态图"><a href="#线程池状态图" class="headerlink" title="线程池状态图"></a>线程池状态图</h3><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;线程池就是一个缓存的概念，将使用完的线程放入到线程池中管理，这样有下一个任务需要执行时，直接从线程池中获取线程执行就行，避免重复的执行线程创建、销毁操作，做到线程复用，从而提高线程的利用率，还能通过线程池来对执行任务的线程进行控制，避免线程被滥用。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="线程池" scheme="https://yingu.site/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】-- SynchronousQueue源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/18/SynchronousQueue/"/>
    <id>https://yingu.site/2020/03/18/SynchronousQueue/</id>
    <published>2020-03-18T10:32:14.000Z</published>
    <updated>2021-07-18T12:31:14.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        <code>SynchronousQueue</code>是一个没有数据缓冲的阻塞队列，生产者线程对其的插入操作<code>put</code>必须等待消费者的移除操作<code>take</code>，反过来也一样。<code>SynchronousQueue</code>中因为不存储元素，所以peek方法永远返回null。 <code>SynchronousQueue</code>支持公平策略。<code>SynchronousQueue</code>看似是阻塞队列中最简单的一种，却是几个解析中最复杂的一个。<a id="more"></a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/SynchronousQueue.png" alt=""></p><ol><li><code>SynchronousQueue</code>实现自<code>BlockingQueue</code>,因此是一个阻塞队列。</li><li><code>SynchronousQueue</code>有一个<code>Transferer</code>内部类，<code>TransferStack</code>与<code>TransferQueue</code>都继承自<code>Transferer</code>，当构建一个非公平队列时，会使用<code>TransferStack</code>以后进先出的顺序访问队列元素，当构建一个公平队列时，则会使用<code>TransferQueue</code>以先进先出的顺序访问队列元素，保证公平。</li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3223113410248163686L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取处理器个数，用于判断后续自旋的条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定超时时的自旋次数,如果处理器个数&lt;2，那么自旋次数为0否则为32</span></span><br><span class="line">    <span class="comment">//处理器只有1个的时候，不需要自旋</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未指定超时的自旋次数，默认为maxTimedSpins * 16，最大为512</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时时间间隔阈值，当超时时间大于此阈值的时候，才有必要阻塞</span></span><br><span class="line">    <span class="comment">//不然可能阻塞一秒马上超时，不如在这一秒之内直接让他快速重试，避免阻塞带来的效率问题</span></span><br><span class="line">    <span class="comment">//也就是优化了这一步，AQS中也有一样的设计</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransferStack类"><a href="#TransferStack类" class="headerlink" title="TransferStack类"></a>TransferStack类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平情况下使用栈，后进先出</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//消费模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//填充模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//匹配中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否正在匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFulfilling</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (m &amp; FULFILLING) != <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下一个等待的节点</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">        <span class="comment">//匹配的节点</span></span><br><span class="line">        <span class="keyword">volatile</span> SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">        <span class="comment">//等待在当前节点上的线程，匹配上之后会释放该线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">        Object item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line">        <span class="keyword">int</span> mode;</span><br><span class="line">        SNode(Object item) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果传入的节点是当前节点的下一个节点，那么替换它为指定节点</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(SNode cmp, SNode val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cmp == next &amp;&amp;</span><br><span class="line">                UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试讲一个节点与当前匹配，成功后会释放当前节点阻塞的线程</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">                Thread w = waiter;</span><br><span class="line">                <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;    <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">                    waiter = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//匹配上了返回true</span></span><br><span class="line">            <span class="keyword">return</span> match == s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试取消</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点是否被取消，当节点的match指向自身的时候，说明被取消了</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> match == <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> matchOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下静态方法都是根据UNSAFE类获取节点的偏移量，用于CAS更新</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = SNode<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                matchOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"match"</span>));</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前链表头，每次都是从头匹配</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置头</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casHead</span><span class="params">(SNode h, SNode nh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h == head &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, h, nh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个节点，如果s为null，那么e作为s中的item</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> SNode <span class="title">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) s = <span class="keyword">new</span> SNode(e);</span><br><span class="line">        s.mode = mode;</span><br><span class="line">        s.next = next;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入或者移除元素，移除时e默认为null</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">        <span class="comment">//判断当前模式，e为null时为REQUEST模式，否则为DATA模式</span></span><br><span class="line">        <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"><span class="comment">//自旋重试</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//记录头结点</span></span><br><span class="line">            SNode h = head;</span><br><span class="line">            <span class="comment">//如果头结点为null或者本次模式与头结点模式相同</span></span><br><span class="line">            <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">                <span class="comment">//如果配置了超时，判断是否已超时</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">                    <span class="comment">//如果超时，头结点不为null并且没有被取消，那么设置下一个节点为新的头结点</span></span><br><span class="line">                    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                        casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//否则返回null</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果没有设置超时，或者还未到超时时间，那么创建一个对象设置为新的头部</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                    <span class="comment">//等待被填充，填充完成后返回匹配节点</span></span><br><span class="line">                    SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                    <span class="comment">//如果匹配节点与等待的节点相同，说明被取消了，需要清理掉节点</span></span><br><span class="line">                    <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">                        clean(s);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//到这里说明匹配成功了，如果当前头部不为null，并且h.next == s</span></span><br><span class="line">                    <span class="comment">//这里是等待匹配的，因此匹配节点应该是头结点，</span></span><br><span class="line">                    <span class="comment">//头结点后面的节点就是我们被匹配的节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                        <span class="comment">//设置新的头结点，也就是s后面的节点</span></span><br><span class="line">                        casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                    <span class="comment">//如果为消费模式，那么返回匹配的元素</span></span><br><span class="line">                    <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                &#125;</span><br><span class="line">             <span class="comment">//如果头结点还没有进行匹配</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">                <span class="comment">//如果头结点被取消，那么设置下一个元素为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">                    casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">                <span class="comment">//设置新的头结点，FULFILLING|mode得到的值要么为2，要么为3</span></span><br><span class="line">                <span class="comment">//通过isFulfilling得到的都是正在匹配</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                        <span class="comment">//记录s的下一个节点m,也就是s要匹配的节点</span></span><br><span class="line">                        SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">                        <span class="comment">//如果m=null,说明被其他节点抢先给匹配了,</span></span><br><span class="line">                        <span class="comment">//并且已经没有其他在等待匹配的节点了</span></span><br><span class="line">                        <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                            <span class="comment">//将头结点置为null，下一次自旋会重新生成，接着往下看</span></span><br><span class="line">                            casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                            <span class="comment">//将s置为null,进行下一次自旋</span></span><br><span class="line">                            s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                            <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//记录m的下一个节点</span></span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        <span class="comment">//进行匹配，tryMatch方法中匹配成功后会释放m中阻塞的线程</span></span><br><span class="line">                        <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                            <span class="comment">//匹配成功后，mn应该置为新的头结点</span></span><br><span class="line">                            casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                            <span class="comment">//根据模式返回匹配的元素</span></span><br><span class="line">                            <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                        &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                            <span class="comment">//如果匹配失败，说明m被其他节点匹配上了</span></span><br><span class="line">                            <span class="comment">//将m从栈中移除，s将对下一个节点进行匹配（也就是mn）</span></span><br><span class="line">                            s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果头结点正在匹配中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">                <span class="comment">//记录头结点的下一个节点，也就是跟头结点进行匹配的节点m</span></span><br><span class="line">                SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">                <span class="comment">//如果m为null</span></span><br><span class="line">                <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">                    <span class="comment">//说明后面没有等待节点了，那么将头结点置为null,继续下一次自旋</span></span><br><span class="line">                    casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//记录m的被匹配的下一个节点</span></span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    <span class="comment">//帮助m与h进行匹配</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">                        <span class="comment">//成功后设置新的头结点为mn</span></span><br><span class="line">                        casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">                    <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">                        <span class="comment">//如果匹配失败，说明m被其他节点匹配上了</span></span><br><span class="line">                        <span class="comment">//将m从栈中移除，h将对下一个节点进行匹配（也就是mn）</span></span><br><span class="line">                        h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待被填充</span></span><br><span class="line">    <span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录超时时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        <span class="comment">//判断当前自旋次数，如果设置了超时则用maxTimedSpins，否则使用maxUntimedSpins</span></span><br><span class="line">        <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                     (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//如果当前线程被中断，那么设置该节点为取消</span></span><br><span class="line">            <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                s.tryCancel();</span><br><span class="line">            <span class="comment">//记录匹配的节点</span></span><br><span class="line">            SNode m = s.match;</span><br><span class="line">            <span class="comment">//&lt;1&gt;.如果不为null，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="comment">//如果配置了超时</span></span><br><span class="line">            <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">//检查是否超时，如果超时会取消当前节点，会将节点的match指向自身</span></span><br><span class="line">                <span class="comment">//然后下次自旋，上面&lt;1&gt;处就会直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    s.tryCancel();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//检查自旋次数是否已经用完</span></span><br><span class="line">            <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//判断是否应该自旋</span></span><br><span class="line">                spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//记录节点上等待的线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">            <span class="comment">//如果没有配置超时，那么直接阻塞</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//如果配置超时了，那么超时阻塞</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前节点为头部，或者头部为null，又或者当前正在匹配中，那么还需要自旋</span></span><br><span class="line">    <span class="comment">//这种时候说明很快就能匹配上了，不需要阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldSpin</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">        SNode h = head;</span><br><span class="line">        <span class="keyword">return</span> (h == s || h == <span class="keyword">null</span> || isFulfilling(h.mode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点被取消后需要清除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将节点的item、waiter置为null</span></span><br><span class="line">        s.item = <span class="keyword">null</span>;   <span class="comment">// forget item</span></span><br><span class="line">        s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line"><span class="comment">//记录要移除节点的下一个节点past</span></span><br><span class="line">        SNode past = s.next;</span><br><span class="line">        <span class="comment">//&lt;1&gt;如果past存在并且被取消，那么找到past后面正常的节点</span></span><br><span class="line">        <span class="keyword">if</span> (past != <span class="keyword">null</span> &amp;&amp; past.isCancelled())</span><br><span class="line">            <span class="comment">//那么继续向下，直到找到一个正常的节点</span></span><br><span class="line">            past = past.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从头节点开始清理</span></span><br><span class="line">        <span class="comment">//如果头节点不为null，并且不是当前找到的最后一个正常的节点，</span></span><br><span class="line">        <span class="comment">//并且头部节点被取消了，那么设置p的下一个节点为头部</span></span><br><span class="line">        <span class="comment">//此时新的头节点还是被取消之后，这步还会继续进行，直到头部被置为null，</span></span><br><span class="line">        <span class="comment">//或者置为一个正常的的节点，上面的&lt;1&gt;处，是从past后面开始找，这里是从head从后面开始找</span></span><br><span class="line">        SNode p;</span><br><span class="line">        <span class="keyword">while</span> ((p = head) != <span class="keyword">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())</span><br><span class="line">            casHead(p, p.next);</span><br><span class="line"><span class="comment">//如果P不为null，说明经过了上一步的while改变了p的值，并且p为一个正常的节点</span></span><br><span class="line">      <span class="comment">//如果p != past，说明p与past之间还有其他节点，针对这中间节点再做一次清理</span></span><br><span class="line">        <span class="comment">//直到清理完整个队列或者past位置为止</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p != past) &#123;</span><br><span class="line">            SNode n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span> &amp;&amp; n.isCancelled())</span><br><span class="line">                p.casNext(n, n.next);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = TransferStack<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            headOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransferQueue类"><a href="#TransferQueue类" class="headerlink" title="TransferQueue类"></a>TransferQueue类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平情况下使用队列，先进先出</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指向队列中的下一个节点</span></span><br><span class="line">        <span class="keyword">volatile</span> QNode next;          <span class="comment">// next node in queue</span></span><br><span class="line">        <span class="comment">//存储元素</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS'ed to or from null</span></span><br><span class="line">        <span class="comment">//节点中的等待线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">        <span class="comment">//是否为插入操作</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//节点构造方法</span></span><br><span class="line">        QNode(Object item, <span class="keyword">boolean</span> isData) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.isData = isData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过cas设置下一个节点</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(QNode cmp, QNode val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next == cmp &amp;&amp;</span><br><span class="line">                UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过cas设置节点的item</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == cmp &amp;&amp;</span><br><span class="line">                UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//尝试取消，节点中的item指向自身，说明被取消</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">tryCancel</span><span class="params">(Object cmp)</span> </span>&#123;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否已经取消</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点是否从已经从队列中移除</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isOffList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next == <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = QNode<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列头节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">    <span class="comment">//队列尾节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line"><span class="comment">//指向一个被取消但是还没有从队列移除的节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line"></span><br><span class="line">    TransferQueue() &#123;</span><br><span class="line">        <span class="comment">//默认初始化一个哨兵节点</span></span><br><span class="line">        QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// initialize to dummy node.</span></span><br><span class="line">        head = h;</span><br><span class="line">        tail = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advanceHead</span><span class="params">(QNode h, QNode nh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == head &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, h, nh))</span><br><span class="line">            h.next = h; <span class="comment">// forget old next</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advanceTail</span><span class="params">(QNode t, QNode nt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == t)</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, t, nt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casCleanMe</span><span class="params">(QNode cmp, QNode val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cleanMe == cmp &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, cleanMeOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">        <span class="comment">//是否是填充数据</span></span><br><span class="line">        <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            QNode t = tail;</span><br><span class="line">            QNode h = head;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">                <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"><span class="comment">//如果队列没有其他元素或者模式相同</span></span><br><span class="line">            <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">                <span class="comment">//记录下一个节点</span></span><br><span class="line">                QNode tn = t.next;</span><br><span class="line">                <span class="comment">//如果t != tail，说明可能有其他节点插入了队列的尾部，重试</span></span><br><span class="line">                <span class="keyword">if</span> (t != tail)            <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//如果t != tail，说明可能有其他节点插入了队列的尾部</span></span><br><span class="line">                <span class="comment">//通过cas更新新的尾部</span></span><br><span class="line">                <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                    advanceTail(t, tn);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//超时</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can't wait</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果s为null，创建一个新节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                    s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">                <span class="comment">//将s添加到队列中，如果失败那么重试</span></span><br><span class="line">                <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//更新尾节点，即使失败，其他节点也会进行这步操作</span></span><br><span class="line">                advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">                <span class="comment">//等待匹配</span></span><br><span class="line">                Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">                <span class="comment">//匹配完成，如果x == s说明，被取消了</span></span><br><span class="line">                <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                    clean(t, s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//如果节点还未从队列中移除</span></span><br><span class="line">                <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                    <span class="comment">//尝试将s置为头从队列中移除</span></span><br><span class="line">                    advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                    <span class="comment">//x!=null说明当前是插入操作</span></span><br><span class="line">                    <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                        <span class="comment">//说明节点被移除</span></span><br><span class="line">                        s.item = s;</span><br><span class="line">                    s.waiter = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是插入操作，那么返回插入的元素，移除操作，返回匹配的元素</span></span><br><span class="line">                <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">                <span class="comment">//如果队列存在元素并且与当前模式不同，那么就直接去队列中匹配</span></span><br><span class="line">                QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">                <span class="comment">//只要存在其中的一种情况，就说明队列被改动过，那么重试</span></span><br><span class="line">                <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"><span class="comment">//记录要匹配的元素</span></span><br><span class="line">                Object x = m.item;</span><br><span class="line">                <span class="comment">//如果isData == (x != null) 它们模式相同，说明已经被匹配了，重试</span></span><br><span class="line">                <span class="comment">//x == m说明被取消了，重试</span></span><br><span class="line">                <span class="comment">//将m的item设置为e表示匹配，如果失败重试</span></span><br><span class="line">                <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                    x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                    !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                    <span class="comment">//出队并重试</span></span><br><span class="line">                    advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//匹配成功</span></span><br><span class="line">                advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">                LockSupport.unpark(m.waiter);</span><br><span class="line">                <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待匹配跟TransferStack中一样</span></span><br><span class="line">    <span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Same idea as TransferStack.awaitFulfill */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">                     (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">            Object x = s.item;</span><br><span class="line">            <span class="keyword">if</span> (x != e)</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    s.tryCancel(e);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">                s.waiter = w;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点被取消后，需要移除，pred为最开始记录尾节点，s是取消的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(QNode pred, QNode s)</span> </span>&#123;</span><br><span class="line">        s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line"><span class="comment">//如果已经断开，那么提前返回</span></span><br><span class="line">        <span class="keyword">while</span> (pred.next == s) &#123; <span class="comment">// Return early if already unlinked</span></span><br><span class="line">            QNode h = head;</span><br><span class="line">            QNode hn = h.next;   <span class="comment">// Absorb cancelled first node as head</span></span><br><span class="line">            <span class="comment">//从头部向后找，如果下一个节点不为null，并且取消了，那么替换头节点</span></span><br><span class="line">            <span class="comment">//直到队列没有其他节点，或者找到一个正常的节点为止</span></span><br><span class="line">            <span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">                advanceHead(h, hn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录尾节点</span></span><br><span class="line">            QNode t = tail;      <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line">            <span class="comment">//如果头节点等于尾节点，那么返回</span></span><br><span class="line">            <span class="keyword">if</span> (t == h)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">//如果t不为尾部节点，说明有新的节点进入到队列中，那么重试</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果tn != null，说明该节点进入到队列中，但是还没有置为尾节点</span></span><br><span class="line">            <span class="comment">//也就是确保新的节点能保证置换为尾节点，虽然其他地方也会执行这部操作</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果s不是尾节点，那么将该节点从队列中移除</span></span><br><span class="line">            <span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">                QNode sn = s.next;</span><br><span class="line">                <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//dp表示被取消但是还未从队列中移除的节点</span></span><br><span class="line">            QNode dp = cleanMe;</span><br><span class="line">            <span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123;    <span class="comment">// Try unlinking previous cancelled node</span></span><br><span class="line">                QNode d = dp.next;</span><br><span class="line">                QNode dn;</span><br><span class="line">                <span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// d is gone or</span></span><br><span class="line">                    d == dp ||                 <span class="comment">// d is off list or</span></span><br><span class="line">                    !d.isCancelled() ||        <span class="comment">// d not cancelled or</span></span><br><span class="line">                    (d != t &amp;&amp;                 <span class="comment">// d not tail and</span></span><br><span class="line">                     (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">//   has successor</span></span><br><span class="line">                     dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">                     dp.casNext(d, dn)))       <span class="comment">// d unspliced</span></span><br><span class="line">                    casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (dp == pred)</span><br><span class="line">                    <span class="keyword">return</span>;      <span class="comment">// s is already saved node</span></span><br><span class="line">                <span class="comment">//移除取消的节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred))</span><br><span class="line">                <span class="keyword">return</span>;          <span class="comment">// Postpone cleaning s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> cleanMeOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = TransferQueue<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            headOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">            tailOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">            cleanMeOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"cleanMe"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，默认使用非公平模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，可以通过fair指定是否位公平模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产方法"><a href="#生产方法" class="headerlink" title="生产方法"></a>生产方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//返回null，表示被取消</span></span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素，超时阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素，返回成功或者失败</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="keyword">true</span>, <span class="number">0</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费方法"><a href="#消费方法" class="headerlink" title="消费方法"></a>消费方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取元素，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果返回为null，说明被取消</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素，超时阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素，如果被取消返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素，由于SynchronousQueue中不存储元素，因此永远返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将队列的元素放入指定集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e; (e = poll()) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        c.add(e);</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将指定个数的队列元素放入指定集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e; n &lt; maxElements &amp;&amp; (e = poll()) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        c.add(e);</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        &lt;code&gt;SynchronousQueue&lt;/code&gt;是一个没有数据缓冲的阻塞队列，生产者线程对其的插入操作&lt;code&gt;put&lt;/code&gt;必须等待消费者的移除操作&lt;code&gt;take&lt;/code&gt;，反过来也一样。&lt;code&gt;SynchronousQueue&lt;/code&gt;中因为不存储元素，所以peek方法永远返回null。 &lt;code&gt;SynchronousQueue&lt;/code&gt;支持公平策略。&lt;code&gt;SynchronousQueue&lt;/code&gt;看似是阻塞队列中最简单的一种，却是几个解析中最复杂的一个。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】-- DelayQueue源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/16/DelayQueue/"/>
    <id>https://yingu.site/2020/03/16/DelayQueue/</id>
    <published>2020-03-16T10:32:14.000Z</published>
    <updated>2021-07-18T12:31:14.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    <code>DelayQueue</code>是一个基于<code>PriorityQueue</code>优先级队列实现的有序的无界阻塞队列。放入队列的元素必须实现Delayed接口，其中的对象只能在其到期时才能从队列中取走。<a id="more"></a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/DelayQueue.png" alt=""></p><ol><li><code>DelayQueue</code>实现了BlockingQueue，具有阻塞队列的特征</li><li>DelayQueue还实现了<code>Delayed</code>接口，实现了 compareTo和getDelay方法，<code>compareTo</code>用于<code>PriorityQueue</code>中对比时间排序， getDelay用于获取剩余时间。</li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PriorityQueue作为内部实现优先级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于优化内部阻塞通知的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于控制的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在上一章<a href=""https://www.yingu.site/2020/03/15/PriorityBlockingQueue/"">PriorityBlockingQueue源码解析中</a>已经介绍过优先阻塞队列了，本章的<code>PriorityQueue</code>跟<code>PriorityBlockingQueue</code>中元素的插入删除操作基本一致，这里就不在介绍了，想了解的可以去看看上一章。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过集合初始化的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类AbstractQueue.class中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产方法"><a href="#生产方法" class="headerlink" title="生产方法"></a>生产方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素，交给offer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过PriorityQueue来实现插入</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">//如果队首元素是刚插入的元素，则设置leader为null，并且唤醒一个阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素，交给offer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素，交给offer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费方法"><a href="#消费方法" class="headerlink" title="消费方法"></a>消费方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除并返回元素，获取不到元素时不回阻塞，直接返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//查看头部元素</span></span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="comment">//如果不存在或者还未到时间，那么返回null</span></span><br><span class="line">        <span class="comment">//first.getDelay方法，获取剩余时间</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则返回</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除并返回元素，响应中断，获取不到元素时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//查看元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="comment">//如果不存在，那么阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取元素的剩余时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">//如果元素时间到了，那么返回</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">//如果已经有等待的线程</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//那么等待被唤醒</span></span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果没有，那么设置当前线程为正在等待的线程</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//等待剩余时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//将leader置为null</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果最终等待的线程不存在，队列不为空，说明没有其他线程再等待，那么通知一个后续的线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除并返回元素，响应中断，获取不到元素时阻塞超时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//检查头部元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果头部不存在，并且已经超时了，那么返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//否则超时阻塞</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取延迟的剩余时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">//时间已到返回元素</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="comment">//如果等待超时返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//释放引用</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">//如果超时的时间小于剩余时间或者没有再等待的线程</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//阻塞超时</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//等待超时，唤醒后返回timeLeft，表示剩余时间</span></span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">//delay - timeLeft表示阻塞已用的时间，最终计算nanos还需要等待的</span></span><br><span class="line">                        <span class="comment">//剩余时间</span></span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果最终等待的线程不存在，队列不为空，说明没有其他线程再等待，那么通知一个后续的线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取头部元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q.peek();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;DelayQueue&lt;/code&gt;是一个基于&lt;code&gt;PriorityQueue&lt;/code&gt;优先级队列实现的有序的无界阻塞队列。放入队列的元素必须实现Delayed接口，其中的对象只能在其到期时才能从队列中取走。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】-- PriorityBlockingQueue源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/15/PriorityBlockingQueue/"/>
    <id>https://yingu.site/2020/03/15/PriorityBlockingQueue/</id>
    <published>2020-03-15T11:09:09.000Z</published>
    <updated>2021-07-18T12:31:14.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        <code>PriorityBlockingQueue</code>一个无界的带有优先级的动态阻塞队列，插入队列的元素默认情况下采用自然顺序升序排列，如果用户传入了Comparator，那么使用传入的Comparator进行排序。<code>PriorityBlockingQueue</code>内部使用一把锁用于消费，当容量到达阈值时，会自动扩容，扩容时由<code>volatile</code>修饰的<code>allocationSpinLock</code>作为cas自旋锁的标识（保证扩容操作不会阻塞take操作）。<a id="more"></a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/PriorityBlockingQueue.png" alt=""></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5595510919245408276L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁用于构建消费的条件锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于消费的条件锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容时，作为cas自旋锁的标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级队列</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法，默认容量为DEFAULT_INITIAL_CAPACITY=11</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带初始化容量的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带初始化容量与比较器的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带集合的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">//是否需要重建堆(堆它是一个数组，不过满足一个特殊的性质)</span></span><br><span class="line">    <span class="keyword">boolean</span> heapify = <span class="keyword">true</span>; <span class="comment">// true if not known to be in heap order</span></span><br><span class="line">    <span class="comment">//是否需要筛选空值</span></span><br><span class="line">    <span class="keyword">boolean</span> screen = <span class="keyword">true</span>;  <span class="comment">// true if must screen for nulls</span></span><br><span class="line">    <span class="comment">//如果传入的是一个有序集合，那么使用集合本身的比较器</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">        heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果传入集合是PriorityBlockingQueue类型，则不进行堆有序化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityBlockingQueue&lt;? extends E&gt; pq =</span><br><span class="line">            (PriorityBlockingQueue&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="comment">//使用阻塞队列的比较器</span></span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">        screen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue<span class="class">.<span class="keyword">class</span>) // <span class="title">exact</span> <span class="title">match</span></span></span><br><span class="line"><span class="class">            <span class="title">heapify</span> </span>= <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">//记录数组长度</span></span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></span><br><span class="line">    <span class="comment">//&lt;1&gt;.如果c.toArray不正确地返回Object[]，请复制它</span></span><br><span class="line">    <span class="keyword">if</span> (a.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">a</span> </span>= Arrays.copyOf(a, n, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//如果传入的集合类型不为有序集合或者PriorityBlockingQueue，那么要校验是否传入null值</span></span><br><span class="line">    <span class="comment">//如果传入的集合中存在null，那么抛出NullPointerException</span></span><br><span class="line">    <span class="comment">// (n == 1 || this.comparator != null) 有两种情况</span></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//讲a赋值给队列内部储存元素的数组</span></span><br><span class="line">    <span class="keyword">this</span>.queue = a;</span><br><span class="line">    <span class="comment">//设置size为n</span></span><br><span class="line">    <span class="keyword">this</span>.size = n;</span><br><span class="line">    <span class="keyword">if</span> (heapify)</span><br><span class="line">        <span class="comment">//是否堆化</span></span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="heapify方法"><a href="#heapify方法" class="headerlink" title="heapify方法"></a>heapify方法</h3><p><code>PriorityBlockingQueue</code>内部采用二叉堆来实现。二叉堆是一种特殊的堆，近似完全二叉树。二叉堆有两种堆：最大堆和最小堆。最大堆：父节点的键值总是大于或者等于任何一个子节点的键值；最小堆：父节点的键值总是小于或等于任何一个子节点的键值。而我们的<code>PriorityBlockingQueue</code>就是采用的最小堆。</p><p>二叉堆一般使用数组来表示，不过他是顺序结构存储而不是链式结构。看图：</p><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/%E4%BA%8C%E5%8F%89%E5%A0%86.jpg" alt=""></p><p><strong>二叉堆来实现优先队列的特点</strong>：</p><ol><li>一般通过数组存储的逻辑二叉树结构</li><li>要么为最大堆要么为最小堆</li><li>父节点索引位 = （当前节点索引位 - 1 ）/ 1</li><li>左子节点索引位 =  当前节点索引位 * 2 + 1</li><li>右子节点索引位 =  当前节点索引位 * 2 + 2</li><li>最后一个非叶子节点索引位 = 节点数/2  - 1；</li></ol><p><strong>二叉堆的三个操作：</strong></p><ol><li>堆化：将一个完全无序的数组转化为一个符合二叉堆结构的数组</li><li>元素插入：为了不破坏现有的二叉堆结构，插入都是从最后一个元素开始，然后对该节点进行上浮操作</li><li>元素移除：删除节点时从堆顶删除，将最后一个节点置换到堆顶，然后对堆顶的元素进行下沉操作</li></ol><p>通过上面的这些特点，以及最后的四个公式，再来看接下来的代码就要轻松许多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//heapify就是上面三个操作中的堆化操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object[] array = queue;</span><br><span class="line">    <span class="keyword">int</span> n = size; </span><br><span class="line">    <span class="comment">//找到最后一个非叶子节点，也就是最后一个节点的父节点</span></span><br><span class="line">    <span class="keyword">int</span> half = (n &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">//如果比较器为null,那么使用自然排序</span></span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从half开始向前数，对所有非叶子节点进行下沉操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDownComparable(i, (E) array[i], array, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDownUsingComparator(i, (E) array[i], array, n, cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点上浮操作"><a href="#节点上浮操作" class="headerlink" title="节点上浮操作"></a>节点上浮操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对节点进行上浮操作，将新插入到末尾的节点进行上浮操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="comment">//k&gt;0说明还有非子叶节点存在</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取父节点的下标</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录父节点的值</span></span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="comment">//经过对比后，如果该节点的优先级已经大于父节点，那么不用进行升序了，break跳出</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//当前下表位置的节点指向父节点</span></span><br><span class="line">        array[k] = e;</span><br><span class="line">        <span class="comment">//k置为parent，接下来通过while会继续向上找，如果此时已经到最顶端了那么</span></span><br><span class="line">        <span class="comment">//k就为0了，就会跳出结束while</span></span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换最终的节点</span></span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟siftUpComparable逻辑一致,不同点就是使用的是用户指定的Comparator比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点下沉操作"><a href="#节点下沉操作" class="headerlink" title="节点下沉操作"></a>节点下沉操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下沉操作，从队列中移除堆顶元素，把最后一个叶子节点替换到头部时，需要进行下沉操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的集合为空，那么就不需要下沉操作了</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">        <span class="comment">//记录二叉树上最后一个非叶子节点的下标，如果当前操作的坐标小于half</span></span><br><span class="line">        <span class="comment">//说明k&gt;half说明k现在记录的位置是叶子节点的位置，不用再下沉了</span></span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line">        <span class="comment">//k小于half说明可能还需要进行下沉操作</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="comment">//获取左子节点下标</span></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            <span class="comment">//记录右子节点</span></span><br><span class="line">            Object c = array[child]; </span><br><span class="line">            <span class="comment">//获取右子节点下标</span></span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果左边的子节点大于右边的子节点，那么就要用右边的右子节点来交换当前节点</span></span><br><span class="line">            <span class="comment">//（目的就是为了取一个最小值来交换）</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="comment">//如果当前节点的值已经小于最小的子节点，那么就不用再进行交换了</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//讲记录的最小的子节点来跟当前节点交换</span></span><br><span class="line">            array[k] = c;</span><br><span class="line">            <span class="comment">//将k指向较小的子节点，以便于下次while循环</span></span><br><span class="line">            <span class="comment">//因为k跟子元素交换之后，子元素可能还有子元素，所以通过k来指向child</span></span><br><span class="line">            <span class="comment">//以便下次继续进行子节点的交换动作</span></span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换最终的节点</span></span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑跟上面的一样</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产方法"><a href="#生产方法" class="headerlink" title="生产方法"></a>生产方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加并返回元素到队列头，由offer方法实现，成功后返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加元素到队列头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列中不允许存储空值</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="comment">//如果当前元素的个数已经&gt;=当前容量，那么就需要扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        <span class="comment">//扩容方法</span></span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="comment">//如果对比器不存在，那么使用自然排序</span></span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//通过上浮，调整堆结构</span></span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        <span class="comment">//元素数+1</span></span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//唤醒一个消费的线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到队列头，由offer方法实现，成功后返回true</span></span><br><span class="line"><span class="comment">//生产方法永远不会被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到队列头，由offer方法实现，成功后返回true</span></span><br><span class="line"><span class="comment">//生产方法永远不会被阻塞，timeout和unit参数在本队列不生效，因为生产是不会阻塞的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e); <span class="comment">// never need to block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryGrow方法"><a href="#tryGrow方法" class="headerlink" title="tryGrow方法"></a>tryGrow方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放锁，保证扩容操作不会阻塞消费</span></span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//释放锁后，扩容会出现竞争</span></span><br><span class="line">    <span class="comment">//allocationSpinLock == 0表示当前没有正在扩容的线程</span></span><br><span class="line">    <span class="comment">//通过cas修改allocationSpinLockOffset为1，表示开始扩容</span></span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果旧的容量&lt;64,那么扩容为原来的2倍+2(容量越小，则增长的越快)，如果原来的容量</span></span><br><span class="line">            <span class="comment">//大于或者等于64，那么扩容为原来的1.5倍</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//如果扩容后的容量&gt;最大容量</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//minCap &lt; 0，说明minCap整数已经溢出了</span></span><br><span class="line">                <span class="comment">//minCap &gt; MAX_ARRAY_SIZE说明已经超出最大限制了</span></span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="comment">//抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                <span class="comment">//设置新容量为最大容量MAX_ARRAY_SIZE</span></span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//newCap &gt; oldCap说明扩容的容量还未超过最大容量，</span></span><br><span class="line">            <span class="comment">//queue == array说明是第一次扩容</span></span><br><span class="line">            <span class="comment">//只有满足这个两个条件，才有必要扩容创建新的数组</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//重置 allocationSpinLock = 0，表示扩容结束</span></span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//newArray == null表示扩容操作被其他线程抢先执行了</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        <span class="comment">//让出cpu资源</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        <span class="comment">//如果newArray != null &amp;&amp; queue == array，说明queue没有发生变化那么讲新的数组指向queue</span></span><br><span class="line">        queue = newArray;</span><br><span class="line">        <span class="comment">//讲原来的array中的值，复制到新的数组中</span></span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费方法"><a href="#消费方法" class="headerlink" title="消费方法"></a>消费方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除队头元素并返回，如果队列为空返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队头元素并返回，如果队列为空阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//出队，如果元素为空那么阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队头元素并返回，如果队列为空超时阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span> &amp;&amp; nanos &gt; <span class="number">0</span>)</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队头元素，如果队列为空返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素出队并返回</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        <span class="comment">//记录头节点</span></span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//记录尾节点</span></span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        <span class="comment">//将尾节点位置置为null</span></span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将原本尾节点x从堆顶进行下沉，调整堆结构，此时原本的头节点result会被替换掉</span></span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="comment">//返回被移除的头节点，也就是堆顶</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次从队列中获取所有元素到指定集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> drainTo(c, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性获取指定元素个数到指定集合中，该方法不会阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//取小值，也就是如果传入的个数超过了队列中已存在的个数，那么以已有的数据为准</span></span><br><span class="line">        <span class="keyword">int</span> n = Math.min(size, maxElements);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//将队头的元素添加到集合中</span></span><br><span class="line">            c.add((E) queue[<span class="number">0</span>]); <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">            <span class="comment">//将队头元素从集合中移除，那么下一次上一步的操作也就是添加新的队头</span></span><br><span class="line">            dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        &lt;code&gt;PriorityBlockingQueue&lt;/code&gt;一个无界的带有优先级的动态阻塞队列，插入队列的元素默认情况下采用自然顺序升序排列，如果用户传入了Comparator，那么使用传入的Comparator进行排序。&lt;code&gt;PriorityBlockingQueue&lt;/code&gt;内部使用一把锁用于消费，当容量到达阈值时，会自动扩容，扩容时由&lt;code&gt;volatile&lt;/code&gt;修饰的&lt;code&gt;allocationSpinLock&lt;/code&gt;作为cas自旋锁的标识（保证扩容操作不会阻塞take操作）。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】-- LinkedBlockingDeque源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/15/LinkedBlockingDeque/"/>
    <id>https://yingu.site/2020/03/15/LinkedBlockingDeque/</id>
    <published>2020-03-15T07:23:21.000Z</published>
    <updated>2021-07-18T12:31:14.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​            <code>LinkedBlockingDeque</code>与<code>LinkedBlockingQueue</code>不同，它是一个由链表组成的无界双端阻塞队列，生产消费用一把锁，头尾都可以生产消费元素，由于多了一个生产插入的入口，因此多线程情况下，入队的效率会提升一倍。<a id="more"></a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/LinkedBlockingDeque.png" alt=""></p><ul><li><code>LinkedBlockingDeque</code>继承<code>AbstractQueued</code>,实现了<code>BlockingDeque</code>，<code>BlockingDeque</code>还继承了<code>BlockingQueue</code>,也就是<code>LinkedBlockingDeque</code>是具备队列的所有基本特性的一个双端队列。</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户储存元素的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向上一个节点</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"><span class="comment">//指向下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制消费的条件锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"><span class="comment">//控制生产的条件锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，默认容量为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过集合初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="comment">//传入的元素，不能为null</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="comment">//将元素插入到队尾，如果传入的集合长度超过默认的容量Integer.MAX_VALUE，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!linkLast(<span class="keyword">new</span> Node&lt;E&gt;(e)))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Deque full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产方法"><a href="#生产方法" class="headerlink" title="生产方法"></a>生产方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素到队尾，队列满的情况下抛出异常，成功添加返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到队尾，队列满的情况下返回false，成功添加返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offerLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到队尾，队列满的情况下会阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    putLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到队尾，队列满的情况下会超时阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offerLast(e, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到队列头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!offerFirst(e))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Deque full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到队列尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!offerLast(e))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Deque full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过linkFirst实现元素的插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkFirst(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过linkLast实现元素的插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkLast(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列头添加元素，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果向队列头添加元素失败，说明队列满了，那么等待</span></span><br><span class="line">        <span class="keyword">while</span> (!linkFirst(node))</span><br><span class="line">            notFull.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列尾添加元素，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果向队列尾添加元素失败，说明队列满了，那么等待</span></span><br><span class="line">        <span class="keyword">while</span> (!linkLast(node))</span><br><span class="line">            notFull.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列头添加元素，响应中断，超时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果向队列头添加元素失败，说明队列满了，那么超时等待</span></span><br><span class="line">        <span class="keyword">while</span> (!linkFirst(node)) &#123;</span><br><span class="line">            <span class="comment">//已超时，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列尾部添加元素，响应中断，超时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//如果向队列尾添加元素失败，说明队列满了，那么超时等待</span></span><br><span class="line">        <span class="keyword">while</span> (!linkLast(node)) &#123;</span><br><span class="line">            <span class="comment">//已超时，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素插入到队列头</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkFirst</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">//必须要先获取锁</span></span><br><span class="line">    <span class="comment">//如果队列已经满了，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//记录头节点</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//插入到头节点</span></span><br><span class="line">    node.next = f;</span><br><span class="line">    <span class="comment">//更新头节点</span></span><br><span class="line">    first = node;</span><br><span class="line">    <span class="comment">//如果尾节点为null,那么设置为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        last = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//将旧的头节点指向新的头节点node</span></span><br><span class="line">        f.prev = node;</span><br><span class="line">    <span class="comment">//元素数量+1</span></span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">//唤醒一个消费的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素插入到队列尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkLast</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">//必须要先获取锁</span></span><br><span class="line">    <span class="comment">//如果队列已经满了，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//记录尾节点</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//将插入节点的prev指向尾节点</span></span><br><span class="line">    node.prev = l;</span><br><span class="line">    <span class="comment">//将node置为新的尾节点</span></span><br><span class="line">    last = node;</span><br><span class="line">    <span class="comment">//如果头为null,那么将node设置为新的头</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        first = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则将原来的尾节点的next指向新的尾节点node</span></span><br><span class="line">        l.next = node;</span><br><span class="line">    <span class="comment">//元素数量+1</span></span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">//唤醒一个消费的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费方法"><a href="#消费方法" class="headerlink" title="消费方法"></a>消费方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除队头元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pollFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> takeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pollFirst(timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将头节点从链表中断开并返回，如果不存在返回null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = f; <span class="comment">// help GC</span></span><br><span class="line">    first = n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n.prev = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将尾节点从链表中断开并返回，如果不存在返回null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; p = l.prev;</span><br><span class="line">    E item = l.item;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = l; <span class="comment">// help GC</span></span><br><span class="line">    last = p;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除头节点并返回，如果队列为空，抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = pollFirst();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队尾点并返回，如果队列为空，抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = pollLast();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队头，通过unlinkFirst方法实现，如果队列为空，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队尾，通过unlinkLast方法实现，如果队列为空，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unlinkLast();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费队头，如果队列为空，那么阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkFirst()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费队尾，如果队列为空，那么阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">takeLast</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkLast()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队头，通过unlinkLast方法实现，如果队列为空，超时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkFirst()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队尾，通过unlinkLast方法实现，如果队列为空，超时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkLast()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队头，如果队列为空，那么抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = peekFirst();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队尾，如果队列为空，那么抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = peekLast();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回队头，如果队列为空，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (first == <span class="keyword">null</span>) ? <span class="keyword">null</span> : first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回队尾，如果队列为空，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (last == <span class="keyword">null</span>) ? <span class="keyword">null</span> : last.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​            &lt;code&gt;LinkedBlockingDeque&lt;/code&gt;与&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;不同，它是一个由链表组成的无界双端阻塞队列，生产消费用一把锁，头尾都可以生产消费元素，由于多了一个生产插入的入口，因此多线程情况下，入队的效率会提升一倍。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】--  LinkedBlockingQueue源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/14/LinkedBlockingQueue/"/>
    <id>https://yingu.site/2020/03/14/LinkedBlockingQueue/</id>
    <published>2020-03-14T08:45:22.000Z</published>
    <updated>2021-07-18T12:31:14.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        <code>LinkedBlockingQueue</code>是由链表组成的单向无界阻塞(严格意义上来并不是无界限) 队列。与<code>ArrayBlockingQueue</code> 不同的是，<code>LinkedBlockingQueue</code>生产消费各用一把锁，生产用的是putLock，消费是takeLock，目的就是为了增大吞吐量，但是因为每个节点都是一个对象，所以比较耗费内存。<a id="more"></a><code>LinkedBlockingQueue</code>默认大小为Integer.MAX_VALUE，如果出现生产大于消费的情况，导致队列中存放着大量未被消费的元素，那么有可能出现OOM。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/LinkedBlockingQueue.png" alt=""></p><p><code>LinkedBlockingQueue</code>继承了抽象队列，并且实现了阻塞队列，因此它具备队列的所有基本特性。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来存放元素的节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line"><span class="comment">//指向下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的元素个数，线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点头（头节点元素值为null,不存放实际数据)</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//控制消费的条件锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//控制生产的条件锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，默认容量为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化头尾节点，内部元素为空</span></span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过集合初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">//从未竞争，但对于可见性而言却是必需的，跟ArrayBlockingQueue中一样，为什么这里要加上锁呢？</span></span><br><span class="line">    putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="comment">//如果传入的集合长度超过默认的容量Integer.MAX_VALUE，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">            <span class="comment">//加入到链表尾部</span></span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素数+1</span></span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产方法"><a href="#生产方法" class="headerlink" title="生产方法"></a>生产方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向队列中添加元素响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//队列不能插入元素为null</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建一个新的节点用于存储元素</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">//&lt;1&gt;.为啥要用AtomicInteger来记录count</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果超过了容量，那么等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入到尾部</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//将容量数+1，但是注意 count.getAndIncrement()结果返回的是count未+1前的结果</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">//如果链表长度没有超过限制容量，那么唤醒其中一个生产线程</span></span><br><span class="line">        <span class="comment">//&lt;2&gt;.为什么要在这里唤醒一个其他的生产线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果c==0，代表之前队列是空的，现在有数据了，那么要释放其他等待的消费线程</span></span><br><span class="line">    <span class="comment">//&lt;3&gt;为什么容量为0的时候才唤醒消费线程，之前不是空的时候，就不能释放么</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素响应中断，超时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算超时时间</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满了阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">//如果超时了直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加元素到队列尾部</span></span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////向队列中添加元素响应中断，获取锁后，如果队列满，立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列还没满</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            <span class="comment">//元素数+1，返回旧的count值</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">//如果队列至少还有一个空余，那么唤醒其中一个生产线程</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放队列不为空的信号，唤醒其中一个消费的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&lt;1&gt;处，为什么我们上面要用到AtomicInteger来更新count,以上面的put方法为例，由于生产消费不是使用的同一把锁，因此使用put方法生产元素的时候，其他生产的线程会被阻塞，但是消费的线程不会阻塞。将count进行自增操作时候，可能会出现不一致的情况。因此必须使用AtomicInteger来保证它的线程安全。</li><li>&lt;2&gt;处，为什么要通过c + 1 &lt; capacity这里判断，来唤醒生产线程，因为notFul这里可能阻塞着多个生产线程，而取元素的时候，只有是队列是满的时候，才会通过signalNotFull()方法唤醒一个生产线程。</li><li>那么，为什么队列满的时候才唤醒notFull呢，因为唤醒是需要加上putLock的，为了减少锁的次数，所以在这里索性就检测一下，未满就释放其他notFull上面的线程。</li><li>&lt;3&gt;处，为什么容量为0的时候才唤醒消费线程，之前不是空的时候，就不能释放么。其实道理跟&lt;2&gt;处，一样都是为了减少锁的次数，才选择到临界条件时，通过获取对方锁来唤醒线程的操作。</li></ul><h3 id="消费方法"><a href="#消费方法" class="headerlink" title="消费方法"></a>消费方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列中消费消息，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列为空，那么阻塞等待被唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将头节点从队列中移除，并返回新的头节点</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">//元素数-1</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//如果队列中至少还有一个元素，那么唤醒别的消费线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果元素数等于容量，也就是说之前队列是满的，现在未满，那么唤醒一个生产线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列中消费消息，响应中断，超时阻塞</span></span><br><span class="line"><span class="comment">//逻辑基本跟上面的一样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列中消费消息，如果发现队列为空，立即返回null,否则将节点从队列中移除并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列中获取最新的元素，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;1&gt;将节点从链表中移除并返回</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    <span class="comment">//头节点的item为null</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">//引用自身，帮助GC回收</span></span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取生产锁，唤醒其他生产线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&lt;1&gt;处。队列中头结点和尾结点一开始总是指向一个哨兵的结点，它不持有实际数据，当队列中有数据时，头结点仍然指向这个哨兵，尾结点指向有效数据的最后一个结点。这样做的好处在于，与计数器 count 结合后，对队头、队尾的访问可以独立进行，而不需要判断头结点与尾结点的关系。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        &lt;code&gt;LinkedBlockingQueue&lt;/code&gt;是由链表组成的单向无界阻塞(严格意义上来并不是无界限) 队列。与&lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 不同的是，&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;生产消费各用一把锁，生产用的是putLock，消费是takeLock，目的就是为了增大吞吐量，但是因为每个节点都是一个对象，所以比较耗费内存。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】-- ArrayBlockingQueue源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/13/ArrayBlockingQueue/"/>
    <id>https://yingu.site/2020/03/13/ArrayBlockingQueue/</id>
    <published>2020-03-13T12:09:32.000Z</published>
    <updated>2021-07-18T12:31:14.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​            <code>ArrayBlockingQueue</code>是由数组组成的一个单向有界阻塞队列。<code>ArrayBlockingQueue</code>内部只有一把锁<code>ReentrantLock</code>，通过<code>ReentrantLock</code>的<code>Condition</code>来控制内部的生产与消费。<code>ArrayBlockingQueue</code>创建时必须指定容量，当队列满后会阻塞生产的线程，队列空时会阻塞消费的线程。<a id="more"></a></p><h2 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h2><p><img src="http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/ArrayBlockingQueue.png" alt=""></p><ol><li><code>ArrayBlockingQueue</code>继承了抽象队列，并且实现了阻塞队列，因此它具备队列的所有基本特性。</li></ol><h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存储内部的元素</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个消费坐标</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//下一个生产坐标</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//当前队列中的元素数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//队列为空的时候，会阻塞消费的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//队列已满的时候，会阻塞消费的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部实现的迭代器，用于迭代items数组</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带容量的构造方法，默认使用非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以指定容量与是否公平锁的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以指定容量与是否公平锁的构造方法，构造后默认向队列中填充元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); &lt;<span class="number">1</span>&gt;.<span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//遍历集合插入到队列中</span></span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="comment">//如果传入的集合长度大于我们设置的容量值，那么会抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录当前队列中元素个数</span></span><br><span class="line">        count = i;</span><br><span class="line">        <span class="comment">//如果队列已经满了，那么下一个生产的数据就存放在items数组的0下标处，也就是从头开始</span></span><br><span class="line">        <span class="comment">//如果没满，那么i就是下一次生产数据插入的位置</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面第三个构造方法中，&lt;1&gt;处，lock.lock()方法处加了一行注释<code>Lock only for visibility, not mutual exclusion</code>，这句话的意思是说，这个锁的操作并不是为了互斥操作，而是保证其可见性。当我们把集合中的数据全部插入队列中之后，我们会修改相应的count以及putIndex的数值，但是如果我们没有加锁，那么在集合插入完成前count以及putIndex没有完成初始化操作的时候如果有其他线程进行了插入等操作的话，会造成数据同步问题从而使得数据不准确。</li></ul><h3 id="生产方法"><a href="#生产方法" class="headerlink" title="生产方法"></a>生产方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向队列中添加元素，如果队列已满直接抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用的父类AbstractQueue.class的add方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类AbstractQueue.class的add方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//会间接调用offer方法</span></span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果失败，那么抛出队列已满异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素，获取锁后立即得到插入结果，不会阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列中不允许添加null元素</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果容量满了，立即返回false</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//向队列添加元素</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素，队列满后会阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//上锁，响应中断</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满了，立刻阻塞，等待被释放</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//释放后，添加元素到队列中</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素，队列满后超时阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">     checkNotNull(e);</span><br><span class="line">    <span class="comment">//计算超时时间</span></span><br><span class="line">     <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                 <span class="comment">//超时直接返回false</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">//如果队列满了，超时阻塞</span></span><br><span class="line">             nanos = notFull.awaitNanos(nanos);</span><br><span class="line">         &#125;</span><br><span class="line">         enqueue(e);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查插入的元素是否为null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNotNull</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//将元素放入当前putIndex下标</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">//++putIndex记录下一次下表位置，如果到队尾了，那么重置下标为0</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//元素数+1</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//有元素入队之后，释放队列不为空信号</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费方法"><a href="#消费方法" class="headerlink" title="消费方法"></a>消费方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费数据，获取锁后立即返回状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列为空，返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费数据，如果队列为空会阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果队列为空，直到队列有元素后，被唤醒</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费数据，如果队列为空会超时阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//超时后，直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//等待超时</span></span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取锁定后立刻返回元素，当队列为空时，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">//记录要出对的元素</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//计算下一次消费的坐标，如果到队列的尾部了，那么从头开始</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//元素数-1</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">//判断当前迭代器是否为空，如果不为空，那么更新迭代器数据</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">//有元素入队之后，释放队列未满信号</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; p = x.prev;</span><br><span class="line">    Node&lt;E&gt; n = x.next;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unlinkFirst();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unlinkLast();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.next = n;</span><br><span class="line">        n.prev = p;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Don't mess with x's links.  They may still be in use by</span></span><br><span class="line">        <span class="comment">// an iterator.</span></span><br><span class="line">        --count;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞队列全部讲完之后，会专门出一章讲阻塞队列中的迭代器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        以上就是<code>ArrayBlockingQueue</code>解析的全部内容了。ArrayBlockingQueue通过一把重入锁创建两条等待队列，分别用于生产与消费的情况，通过putIndex与takeIndex用于记录下一个元素入队与出队处的下标。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​            &lt;code&gt;ArrayBlockingQueue&lt;/code&gt;是由数组组成的一个单向有界阻塞队列。&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;内部只有一把锁&lt;code&gt;ReentrantLock&lt;/code&gt;，通过&lt;code&gt;ReentrantLock&lt;/code&gt;的&lt;code&gt;Condition&lt;/code&gt;来控制内部的生产与消费。&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;创建时必须指定容量，当队列满后会阻塞生产的线程，队列空时会阻塞消费的线程。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】-- BlockingQueue总结(jdk1.8)</title>
    <link href="https://yingu.site/2020/03/13/BlockingQueue/"/>
    <id>https://yingu.site/2020/03/13/BlockingQueue/</id>
    <published>2020-03-13T11:11:21.000Z</published>
    <updated>2021-07-18T12:31:14.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​            <code>BlockingQueue</code>即是我们所说的阻塞队列，它是一个接口，继承自Queue接口。后面我们要讲的阻塞队列，都实现自该接口。包括：<a id="more"></a></p><ul><li><a href=""https://www.yingu.site/2020/03/13/ArrayBlockingQueue/"">ArrayBlockingQueue</a></li><li><a href=""https://www.yingu.site/2020/03/14/LinkedBlockingQueue/"">LinkedBlockingQueue</a></li><li><a href=""https://www.yingu.site/2020/03/15/LinkedBlockingDeque/"">LinkedBlockingDeque</a>(实现了<code>BlockingDeque</code>，<code>BlockingDeque</code>继承自<code>BlockingQueue</code>)</li><li><a href=""https://www.yingu.site/2020/03/15/PriorityBlockingQueue/"">PriorityBlockingQueue</a></li><li>…</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>​        <code>BlockingQueue</code> 具有不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。而通过<code>BlockingQueue</code> 实现的阻塞队列，也保留了这些特性。</p><h3 id="生产方法"><a href="#生产方法" class="headerlink" title="生产方法"></a>生产方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向队列中添加元素，如果队列已满直接抛出IllegalStateException异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素，如果队列已满返回false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素，队列已满会阻塞等待，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素，队列已满会超时阻塞等待，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h3 id="消费方法"><a href="#消费方法" class="headerlink" title="消费方法"></a>消费方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取并移除头部元素，如果队列为空会阻塞，响应中断</span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并移除头部元素，如果队列为空返回null</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并移除头部元素，如果队列为空超时阻塞，超时后返回null，并且可以响应中断</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取头部元素，如果队列为空返回null</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次从队列中获取所有元素到指定集合中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性获取指定元素个数到指定集合中，该方法不会阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​            &lt;code&gt;BlockingQueue&lt;/code&gt;即是我们所说的阻塞队列，它是一个接口，继承自Queue接口。后面我们要讲的阻塞队列，都实现自该接口。包括：
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="阻塞队列" scheme="https://yingu.site/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】-- CyclicBarrier源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2019/12/25/CyclicBarrier/"/>
    <id>https://yingu.site/2019/12/25/CyclicBarrier/</id>
    <published>2019-12-25T12:41:01.000Z</published>
    <updated>2021-07-18T12:31:14.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        <code>CyclicBarrier</code>与<code>CountDownLatch</code>类似，它们都是阻塞一组线程直到某个事件的发生。<code>CyclicBarrier</code>与<code>CountDownLatch</code>的关键区别在于，<code>CyclicBarrier</code>中的所有的线程必须同时达到屏蔽点才能继续执行，如果其中一个线程被中断，那么所有的等待的线程都会立刻被唤醒，并且抛出异常。而<code>CountDownLatch</code>中线程之间不会收到干扰。<code>CyclicBarrier</code>可以复用，每次打破屏障后，都会生成一个新的屏障，供下次使用，而<code>CountDownLatch</code>用一次之后就无效了。</p><a id="more"></a><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类，表示屏障</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前屏障是否被打破，屏障被打破后，等待的线程才会执行</span></span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏障拦截的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栅栏打破后，执行的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始一个新的屏障</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏障被打破后，会调用此方法，重置屏障，以便下次复用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//唤醒所有等待的线程</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">//初始化拦截的线程数</span></span><br><span class="line">        count = parties;</span><br><span class="line">        <span class="comment">//初始化新的屏障</span></span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打破屏障</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//屏障标识设置为true，标识被打破</span></span><br><span class="line">        generation.broken = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//初始化拦截的线程数</span></span><br><span class="line">        count = parties;</span><br><span class="line">        <span class="comment">//唤醒所有等待的线程</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程等待，timed是否超时，超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"><span class="comment">//如果屏障已经被打破，那么抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">//如果线程被中断，那么打破当前屏障，其他被拦截到屏障前的线程将得到释放</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//当前拦截数-1</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line">            <span class="comment">//如果拦截数为0，说明达到了突破屏障的条件</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="comment">//标记执行状态</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="comment">//如果预设的打破屏障后的方法存在，那么执行</span></span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//重置屏障</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//栅栏打破后，执行的线程如果出现异常，或者屏障重置失败，那么打破屏障</span></span><br><span class="line">                    <span class="comment">//打破屏障后，所有等待的线程都将被唤醒，并抛出BrokenBarrierException异常</span></span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果当前还没有达到打破屏障的条件，并且线程未被中断</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//是否锁超时</span></span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        <span class="comment">//如果没启用，那么直接调用条件锁的等待方法，响应中断</span></span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        <span class="comment">//如果启用，那么直接调用条件锁的超时等待方法，响应中断</span></span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="comment">//如果等待的途中，被中断</span></span><br><span class="line">                    <span class="comment">//判断当前屏障是被重置，并且未被打破</span></span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        <span class="comment">//那么打破屏障</span></span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果屏障已经被其他线程重置了，或者被打破了，那么响应中断</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//判断屏障是否被打破，如果被打破，那么抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">//如果屏障被重置，说明已经达到突破屏障的条件了，返回index,执行线程</span></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"><span class="comment">//如果当前启动锁超时，那么检测当前是否等待超时，如果等待超时</span></span><br><span class="line">                <span class="comment">//那么打破屏障</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//无论是否成功，最终都会释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栅栏的初始方法，执行一个等待屏障的线程数parties，以及打破屏障后执行的一个Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待阻塞，直到屏障被打破</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待阻塞，直到屏障被打破或者超时等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">               BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前屏障是否被打破</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> generation.broken;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置屏障</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//跳过当前的屏障，之前的等待的线程，会抛出异常</span></span><br><span class="line">            breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">            <span class="comment">//打开一个新的屏障</span></span><br><span class="line">            nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取等待的线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parties - count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        &lt;code&gt;CyclicBarrier&lt;/code&gt;与&lt;code&gt;CountDownLatch&lt;/code&gt;类似，它们都是阻塞一组线程直到某个事件的发生。&lt;code&gt;CyclicBarrier&lt;/code&gt;与&lt;code&gt;CountDownLatch&lt;/code&gt;的关键区别在于，&lt;code&gt;CyclicBarrier&lt;/code&gt;中的所有的线程必须同时达到屏蔽点才能继续执行，如果其中一个线程被中断，那么所有的等待的线程都会立刻被唤醒，并且抛出异常。而&lt;code&gt;CountDownLatch&lt;/code&gt;中线程之间不会收到干扰。&lt;code&gt;CyclicBarrier&lt;/code&gt;可以复用，每次打破屏障后，都会生成一个新的屏障，供下次使用，而&lt;code&gt;CountDownLatch&lt;/code&gt;用一次之后就无效了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="并发" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="并发" scheme="https://yingu.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="juc" scheme="https://yingu.site/tags/juc/"/>
    
      <category term="锁" scheme="https://yingu.site/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>【阻塞队列】--  Semaphore源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2019/12/01/Semaphore/"/>
    <id>https://yingu.site/2019/12/01/Semaphore/</id>
    <published>2019-12-01T13:23:13.000Z</published>
    <updated>2021-07-18T12:31:14.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        上一篇我们解析了<code>CountDownLatch</code>，<code>Semaphore</code>、<code>CyclicBarrier</code>跟<code>CountDownLatch</code>一样，都是基于AQS实现的同步工具类。<code>Semaphore</code>用来控制线程的并发，初始时会指定一个许可数permits，线程执行前需要获取许可，获取到许可后许可数-1，线程会向下执行，如果没有可用许可，就会被阻塞。直到其他线程执行完成释放许可后，被阻塞线程才会继续尝试获取许可。<a id="more"></a>也就是说<code>Semaphore</code>可以控制线程的并发量，如果一个线程执行完了，归还了许可，那么下一个线程才有机会获取许可，将同时执行的线程控制在设置的permits范围以内。</p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于AQS实现的共享锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///构造方法，设置设置许可数</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前剩余许可</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取非公平共享锁</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">//计算剩余许可</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="comment">//如果remaining &lt; 0，说明许可已经用完了，此时返回remaining == -1，表示获取失败</span></span><br><span class="line">                <span class="comment">//创建记录该线程的node节点加入到同步队列中，等待被唤醒</span></span><br><span class="line">                <span class="comment">//如果CAS设置成功，返回remaining的值，肯定&gt;-1,代表成功</span></span><br><span class="line">                <span class="comment">//如果CAS设置失败，表示许可被其他线程抢到，重试</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试释放共享</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">//next &lt; current，说明releases&lt;0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">//更新许可</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">                <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取并返回立即可用的所有许可个数，并且将可用许可置0。</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//立马抢锁，许可有可能被新抢锁的线程获取</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//公平锁，会先检查同步队列中是否有其他的节点，如果存在的话，返回-1获取锁失败</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//同步队列中是否存在节点</span></span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">//记录新的可用许可数</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，指定许可数，默认采用非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，指定许可数，是否使用公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁，响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁，不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁，指定许可数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireSharedInterruptibly(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁，指定许可，响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁，指定许可数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquireShared(permits) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.releaseShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取可以用的许可数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getPermits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取并返回立即可用的所有许可个数，并且将可用许可置0。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.drainPermits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reduction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reduction &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.reducePermits(reduction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前是否为公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync <span class="keyword">instanceof</span> FairSync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前同步队列中是否存在等待的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getQueueLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Permits = "</span> + sync.getPermits() + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        上一篇我们解析了&lt;code&gt;CountDownLatch&lt;/code&gt;，&lt;code&gt;Semaphore&lt;/code&gt;、&lt;code&gt;CyclicBarrier&lt;/code&gt;跟&lt;code&gt;CountDownLatch&lt;/code&gt;一样，都是基于AQS实现的同步工具类。&lt;code&gt;Semaphore&lt;/code&gt;用来控制线程的并发，初始时会指定一个许可数permits，线程执行前需要获取许可，获取到许可后许可数-1，线程会向下执行，如果没有可用许可，就会被阻塞。直到其他线程执行完成释放许可后，被阻塞线程才会继续尝试获取许可。
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="并发" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="并发" scheme="https://yingu.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="juc" scheme="https://yingu.site/tags/juc/"/>
    
      <category term="锁" scheme="https://yingu.site/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch源码解析(jdk1.8)</title>
    <link href="https://yingu.site/2019/11/23/CountDownLatch/"/>
    <id>https://yingu.site/2019/11/23/CountDownLatch/</id>
    <published>2019-11-23T14:33:54.000Z</published>
    <updated>2021-07-18T12:31:14.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        <code>CountDownLatch</code>是基于AQS实现的一个同步工具类。它允许一个线程一直等待，直到其他线程执行完成后再执行。<code>CountDownLatch</code>源码比较简单，基于AQS实现共享锁的等待 ，初始化时只需要设置一个初始值，后续针对锁的状态进行控制，最后根据锁的状态来释放等待线程即可。<code>CountDownLatch</code>跟<code>CyclicBarrier</code>不同，8.19是不可复用的，<code>CountDownLatch</code>释放等待线程后，就不能再次使用了。看此源码之前，建议先看<a href=""https://www.yingu.site/2019/07/26/AbstractQueuedSynchronizer/"">AQS源码解析</a>。</p><a id="more"></a><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>以下就是<code>CountDownLatch</code>的全部代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于AQS实现的共享锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造方法，设置一个初始count，</span></span><br><span class="line">        <span class="comment">//当count==0时，释放被await方法阻塞的线程</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取锁的state状态，也就是count</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试获取共享锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果state已经为0了，返回1，后续的await操作不会被阻塞，也就是说</span></span><br><span class="line">            <span class="comment">//CountDownLatch已经失效了，如果返回-1，获取锁失败，那么会创建记录该线程</span></span><br><span class="line">            <span class="comment">//的node节点加入到同步队列中，等待被唤醒</span></span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试释放共享锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="comment">//如果state为0，直接返回false，表示锁未完全释放</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//否则，将state-1</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">//如果nextc已经为0，说明当前锁已经完全释放了，返回成功</span></span><br><span class="line">                    <span class="comment">//通过共享锁的传播性，最终所有被await阻塞的线程，都会被陆续唤醒</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始值不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞调用线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//调用AQS的方法，响应中断</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时阻塞调用线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一次调用countDown时，state都会-1，直到state==0为止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//释放共享锁，state会-1，state=0时，会释放await等待的线程。</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前数量，也就是还需要执行多少次countDown后才会释放await等待线程的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Count = "</span> + sync.getCount() + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        上面就是针对<code>CountDownLatch</code>的全部解析了，可以看出来代码量很少，实现的逻辑也很简单(主要的代码都在AQS中)。<code>CountDownLatch</code>就像是一个计数器，初始化时执行一个计数值，每一次调用countDown时，就将值-1，当值到0时，释放等待线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        &lt;code&gt;CountDownLatch&lt;/code&gt;是基于AQS实现的一个同步工具类。它允许一个线程一直等待，直到其他线程执行完成后再执行。&lt;code&gt;CountDownLatch&lt;/code&gt;源码比较简单，基于AQS实现共享锁的等待 ，初始化时只需要设置一个初始值，后续针对锁的状态进行控制，最后根据锁的状态来释放等待线程即可。&lt;code&gt;CountDownLatch&lt;/code&gt;跟&lt;code&gt;CyclicBarrier&lt;/code&gt;不同，8.19是不可复用的，&lt;code&gt;CountDownLatch&lt;/code&gt;释放等待线程后，就不能再次使用了。看此源码之前，建议先看&lt;a href=&quot;&quot;https://www.yingu.site/2019/07/26/AbstractQueuedSynchronizer/&quot;&quot;&gt;AQS源码解析&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="并发" scheme="https://yingu.site/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="源码" scheme="https://yingu.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="java" scheme="https://yingu.site/tags/java/"/>
    
      <category term="并发" scheme="https://yingu.site/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="juc" scheme="https://yingu.site/tags/juc/"/>
    
      <category term="锁" scheme="https://yingu.site/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
