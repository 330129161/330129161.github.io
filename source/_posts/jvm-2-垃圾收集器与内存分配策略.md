title: 【深入理解java虚拟机】-- 2.垃圾收集器与内存分配策略

author: yingu

thumbnail: http://yingu-blog.oss-cn-hangzhou.aliyuncs.com/book.png

toc: true 

tags:

  - jvm

categories: 

  - [jvm,垃圾回收] 

date: 2019-12-25 20:41:01

---

> 本系列内容，大量引用自《[深入理解java虚拟机](https://book.douban.com/subject/6522893/)》，说是照抄一遍也不为过。不过作者自己也加入了一些图文用来帮助理解。

## 对象是否存活

在堆中存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，那些已经“死去”(即不能再被任何途径使用的对象)。

### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它时，计时器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象，就是不可能再被使用的。这种方式虽然实现简单、效率也很高，但是主流的java虚拟机里面没有选用引用计数法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。例如：

```java
Object q1 = new GcObject(); //实例1，引用数+1
Object q2 = new GcObject(); //实例2，引用数+1

q1.instance = q2; //将实例1中的instance熟悉指向实例2，实例2，引用数+1
q2.instance = q1; //将实例2中的instance熟悉指向实例1，实例1，引用数+1

q1 = null; //实例1，引用数-1
q2 = null; //实例2，引用数-1

//垃圾回收后，实例1，实例2还存在堆中，不会被回收
System.gc();
```

上面代表就描述了，引用计数器在实际使用中会出现的一个循环引用的问题。对象没有被其他地方应用，但是计数器值不为0，此时实例1、2无法被回收。

### 可达性分析算法

### 再谈引用

### 生存还是死亡

### 回收方法区

## 垃圾收集算法

## hptspot的算法实现

## 垃圾收集器

## 内存分配与回收策略